/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.gles.ext2;

private {
    import derelict.gles.types2;
    import derelict.gles.constants2;
    import derelict.gles.internal;
}

private __gshared bool _GL_KHR_blend_equation_advanced;
bool GL_KHR_blend_equation_advanced() @property { return _GL_KHR_blend_equation_advanced; }
enum : uint {
    GL_BLEND_ADVANCED_COHERENT_KHR    = 0x9285,
    GL_MULTIPLY_KHR                   = 0x9294,
    GL_SCREEN_KHR                     = 0x9295,
    GL_OVERLAY_KHR                    = 0x9296,
    GL_DARKEN_KHR                     = 0x9297,
    GL_LIGHTEN_KHR                    = 0x9298,
    GL_COLORDODGE_KHR                 = 0x9299,
    GL_COLORBURN_KHR                  = 0x929A,
    GL_HARDLIGHT_KHR                  = 0x929B,
    GL_SOFTLIGHT_KHR                  = 0x929C,
    GL_DIFFERENCE_KHR                 = 0x929E,
    GL_EXCLUSION_KHR                  = 0x92A0,
    GL_HSL_HUE_KHR                    = 0x92AD,
    GL_HSL_SATURATION_KHR             = 0x92AE,
    GL_HSL_COLOR_KHR                  = 0x92AF,
    GL_HSL_LUMINOSITY_KHR             = 0x92B0,
}
extern( System ) nothrow {
    alias da_glBlendBarrierKHR = void function(  );
}
__gshared {
    da_glBlendBarrierKHR glBlendBarrierKHR;
}
private void load_GL_KHR_blend_equation_advanced() {
    try {
        bindGLFunc( cast( void** )&glBlendBarrierKHR, "glBlendBarrierKHR" );

        _GL_KHR_blend_equation_advanced = true;
    } catch( Exception e ) {
        _GL_KHR_blend_equation_advanced = false;
    }
}

private __gshared bool _GL_KHR_debug;
bool GL_KHR_debug() @property { return _GL_KHR_debug; }
alias GLDEBUGPROCKHR = void function( GLenum, GLenum, GLuint, GLenum, GLsizei, const GLchar*, const void* );
enum : uint {
    GL_SAMPLER                        = 0x82E6,
    GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR   = 0x8242,
    GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = 0x8243,
    GL_DEBUG_CALLBACK_FUNCTION_KHR    = 0x8244,
    GL_DEBUG_CALLBACK_USER_PARAM_KHR  = 0x8245,
    GL_DEBUG_SOURCE_API_KHR           = 0x8246,
    GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = 0x8247,
    GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = 0x8248,
    GL_DEBUG_SOURCE_THIRD_PARTY_KHR   = 0x8249,
    GL_DEBUG_SOURCE_APPLICATION_KHR   = 0x824A,
    GL_DEBUG_SOURCE_OTHER_KHR         = 0x824B,
    GL_DEBUG_TYPE_ERROR_KHR           = 0x824C,
    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = 0x824D,
    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = 0x824E,
    GL_DEBUG_TYPE_PORTABILITY_KHR     = 0x824F,
    GL_DEBUG_TYPE_PERFORMANCE_KHR     = 0x8250,
    GL_DEBUG_TYPE_OTHER_KHR           = 0x8251,
    GL_DEBUG_TYPE_MARKER_KHR          = 0x8268,
    GL_DEBUG_TYPE_PUSH_GROUP_KHR      = 0x8269,
    GL_DEBUG_TYPE_POP_GROUP_KHR       = 0x826A,
    GL_DEBUG_SEVERITY_NOTIFICATION_KHR = 0x826B,
    GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826C,
    GL_DEBUG_GROUP_STACK_DEPTH_KHR    = 0x826D,
    GL_BUFFER_KHR                     = 0x82E0,
    GL_SHADER_KHR                     = 0x82E1,
    GL_PROGRAM_KHR                    = 0x82E2,
    GL_VERTEX_ARRAY_KHR               = 0x8074,
    GL_QUERY_KHR                      = 0x82E3,
    GL_SAMPLER_KHR                    = 0x82E6,
    GL_MAX_LABEL_LENGTH_KHR           = 0x82E8,
    GL_MAX_DEBUG_MESSAGE_LENGTH_KHR   = 0x9143,
    GL_MAX_DEBUG_LOGGED_MESSAGES_KHR  = 0x9144,
    GL_DEBUG_LOGGED_MESSAGES_KHR      = 0x9145,
    GL_DEBUG_SEVERITY_HIGH_KHR        = 0x9146,
    GL_DEBUG_SEVERITY_MEDIUM_KHR      = 0x9147,
    GL_DEBUG_SEVERITY_LOW_KHR         = 0x9148,
    GL_DEBUG_OUTPUT_KHR               = 0x92E0,
    GL_CONTEXT_FLAG_DEBUG_BIT_KHR     = 0x00000002,
    GL_STACK_OVERFLOW_KHR             = 0x0503,
    GL_STACK_UNDERFLOW_KHR            = 0x0504,
}
extern( System ) nothrow {
    alias da_glDebugMessageControlKHR = void function( GLenum, GLenum, GLenum, GLsizei, const GLuint*, GLboolean );
    alias da_glDebugMessageInsertKHR = void function( GLenum, GLenum, GLuint, GLenum, GLsizei, const GLchar* );
    alias da_glDebugMessageCallbackKHR = void function( GLDEBUGPROCKHR, const void* );
    alias da_glGetDebugMessageLogKHR = GLuint function ( GLuint, GLsizei, GLenum*, GLenum*, GLuint*, GLenum*, GLsizei*, GLchar* );
    alias da_glPushDebugGroupKHR = void function( GLenum, GLuint, GLsizei, const GLchar* );
    alias da_glPopDebugGroupKHR = void function(  );
    alias da_glObjectLabelKHR = void function( GLenum, GLuint, GLsizei, const GLchar* );
    alias da_glGetObjectLabelKHR = void function( GLenum, GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glObjectPtrLabelKHR = void function( const void*, GLsizei, const GLchar* );
    alias da_glGetObjectPtrLabelKHR = void function( const void*, GLsizei, GLsizei*, GLchar* );
    alias da_glGetPointervKHR = void function( GLenum, void** );
}
__gshared {
    da_glDebugMessageControlKHR glDebugMessageControlKHR;
    da_glDebugMessageInsertKHR glDebugMessageInsertKHR;
    da_glDebugMessageCallbackKHR glDebugMessageCallbackKHR;
    da_glGetDebugMessageLogKHR glGetDebugMessageLogKHR;
    da_glPushDebugGroupKHR glPushDebugGroupKHR;
    da_glPopDebugGroupKHR glPopDebugGroupKHR;
    da_glObjectLabelKHR glObjectLabelKHR;
    da_glGetObjectLabelKHR glGetObjectLabelKHR;
    da_glObjectPtrLabelKHR glObjectPtrLabelKHR;
    da_glGetObjectPtrLabelKHR glGetObjectPtrLabelKHR;
    da_glGetPointervKHR glGetPointervKHR;
}
private void load_GL_KHR_debug() {
    try {
        bindGLFunc( cast( void** )&glDebugMessageControlKHR, "glDebugMessageControlKHR" );
        bindGLFunc( cast( void** )&glDebugMessageInsertKHR, "glDebugMessageInsertKHR" );
        bindGLFunc( cast( void** )&glDebugMessageCallbackKHR, "glDebugMessageCallbackKHR" );
        bindGLFunc( cast( void** )&glGetDebugMessageLogKHR, "glGetDebugMessageLogKHR" );
        bindGLFunc( cast( void** )&glPushDebugGroupKHR, "glPushDebugGroupKHR" );
        bindGLFunc( cast( void** )&glPopDebugGroupKHR, "glPopDebugGroupKHR" );
        bindGLFunc( cast( void** )&glObjectLabelKHR, "glObjectLabelKHR" );
        bindGLFunc( cast( void** )&glGetObjectLabelKHR, "glGetObjectLabelKHR" );
        bindGLFunc( cast( void** )&glObjectPtrLabelKHR, "glObjectPtrLabelKHR" );
        bindGLFunc( cast( void** )&glGetObjectPtrLabelKHR, "glGetObjectPtrLabelKHR" );
        bindGLFunc( cast( void** )&glGetPointervKHR, "glGetPointervKHR" );

        _GL_KHR_debug = true;
    } catch( Exception e ) {
        _GL_KHR_debug = false;
    }
}

private __gshared bool _GL_KHR_texture_compression_astc_hdr;
bool GL_KHR_texture_compression_astc_hdr() @property { return _GL_KHR_texture_compression_astc_hdr; }
enum : uint {
    GL_COMPRESSED_RGBA_ASTC_4x4_KHR   = 0x93B0,
    GL_COMPRESSED_RGBA_ASTC_5x4_KHR   = 0x93B1,
    GL_COMPRESSED_RGBA_ASTC_5x5_KHR   = 0x93B2,
    GL_COMPRESSED_RGBA_ASTC_6x5_KHR   = 0x93B3,
    GL_COMPRESSED_RGBA_ASTC_6x6_KHR   = 0x93B4,
    GL_COMPRESSED_RGBA_ASTC_8x5_KHR   = 0x93B5,
    GL_COMPRESSED_RGBA_ASTC_8x6_KHR   = 0x93B6,
    GL_COMPRESSED_RGBA_ASTC_8x8_KHR   = 0x93B7,
    GL_COMPRESSED_RGBA_ASTC_10x5_KHR  = 0x93B8,
    GL_COMPRESSED_RGBA_ASTC_10x6_KHR  = 0x93B9,
    GL_COMPRESSED_RGBA_ASTC_10x8_KHR  = 0x93BA,
    GL_COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB,
    GL_COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC,
    GL_COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD,
}

private __gshared bool _GL_KHR_texture_compression_astc_ldr;
bool GL_KHR_texture_compression_astc_ldr() @property { return _GL_KHR_texture_compression_astc_ldr; }

private __gshared bool _GL_OES_EGL_image;
bool GL_OES_EGL_image() @property { return _GL_OES_EGL_image; }
alias GLeglImageOES = void*;
extern( System ) nothrow {
    alias da_glEGLImageTargetTexture2DOES = void function( GLenum, GLeglImageOES );
    alias da_glEGLImageTargetRenderbufferStorageOES = void function( GLenum, GLeglImageOES );
}
__gshared {
    da_glEGLImageTargetTexture2DOES glEGLImageTargetTexture2DOES;
    da_glEGLImageTargetRenderbufferStorageOES glEGLImageTargetRenderbufferStorageOES;
}
private void load_GL_OES_EGL_image() {
    try {
        bindGLFunc( cast( void** )&glEGLImageTargetTexture2DOES, "glEGLImageTargetTexture2DOES" );
        bindGLFunc( cast( void** )&glEGLImageTargetRenderbufferStorageOES, "glEGLImageTargetRenderbufferStorageOES" );

        _GL_OES_EGL_image = true;
    } catch( Exception e ) {
        _GL_OES_EGL_image = false;
    }
}

private __gshared bool _GL_OES_EGL_image_external;
bool GL_OES_EGL_image_external() @property { return _GL_OES_EGL_image_external; }
enum : uint {
    GL_TEXTURE_EXTERNAL_OES           = 0x8D65,
    GL_TEXTURE_BINDING_EXTERNAL_OES   = 0x8D67,
    GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES = 0x8D68,
    GL_SAMPLER_EXTERNAL_OES           = 0x8D66,
}

private __gshared bool _GL_OES_compressed_ETC1_RGB8_texture;
bool GL_OES_compressed_ETC1_RGB8_texture() @property { return _GL_OES_compressed_ETC1_RGB8_texture; }
enum : uint {
    GL_ETC1_RGB8_OES                  = 0x8D64,
}

private __gshared bool _GL_OES_compressed_paletted_texture;
bool GL_OES_compressed_paletted_texture() @property { return _GL_OES_compressed_paletted_texture; }
enum : uint {
    GL_PALETTE4_RGB8_OES              = 0x8B90,
    GL_PALETTE4_RGBA8_OES             = 0x8B91,
    GL_PALETTE4_R5_G6_B5_OES          = 0x8B92,
    GL_PALETTE4_RGBA4_OES             = 0x8B93,
    GL_PALETTE4_RGB5_A1_OES           = 0x8B94,
    GL_PALETTE8_RGB8_OES              = 0x8B95,
    GL_PALETTE8_RGBA8_OES             = 0x8B96,
    GL_PALETTE8_R5_G6_B5_OES          = 0x8B97,
    GL_PALETTE8_RGBA4_OES             = 0x8B98,
    GL_PALETTE8_RGB5_A1_OES           = 0x8B99,
}

private __gshared bool _GL_OES_depth24;
bool GL_OES_depth24() @property { return _GL_OES_depth24; }
enum : uint {
    GL_DEPTH_COMPONENT24_OES          = 0x81A6,
}

private __gshared bool _GL_OES_depth32;
bool GL_OES_depth32() @property { return _GL_OES_depth32; }
enum : uint {
    GL_DEPTH_COMPONENT32_OES          = 0x81A7,
}

private __gshared bool _GL_OES_depth_texture;
bool GL_OES_depth_texture() @property { return _GL_OES_depth_texture; }

private __gshared bool _GL_OES_element_index_uint;
bool GL_OES_element_index_uint() @property { return _GL_OES_element_index_uint; }

private __gshared bool _GL_OES_fbo_render_mipmap;
bool GL_OES_fbo_render_mipmap() @property { return _GL_OES_fbo_render_mipmap; }

private __gshared bool _GL_OES_fragment_precision_high;
bool GL_OES_fragment_precision_high() @property { return _GL_OES_fragment_precision_high; }

private __gshared bool _GL_OES_get_program_binary;
bool GL_OES_get_program_binary() @property { return _GL_OES_get_program_binary; }
enum : uint {
    GL_PROGRAM_BINARY_LENGTH_OES      = 0x8741,
    GL_NUM_PROGRAM_BINARY_FORMATS_OES = 0x87FE,
    GL_PROGRAM_BINARY_FORMATS_OES     = 0x87FF,
}
extern( System ) nothrow {
    alias da_glGetProgramBinaryOES = void function( GLuint, GLsizei, GLsizei*, GLenum*, void* );
    alias da_glProgramBinaryOES = void function( GLuint, GLenum, const void*, GLint );
}
__gshared {
    da_glGetProgramBinaryOES glGetProgramBinaryOES;
    da_glProgramBinaryOES glProgramBinaryOES;
}
private void load_GL_OES_get_program_binary() {
    try {
        bindGLFunc( cast( void** )&glGetProgramBinaryOES, "glGetProgramBinaryOES" );
        bindGLFunc( cast( void** )&glProgramBinaryOES, "glProgramBinaryOES" );

        _GL_OES_get_program_binary = true;
    } catch( Exception e ) {
        _GL_OES_get_program_binary = false;
    }
}

private __gshared bool _GL_OES_mapbuffer;
bool GL_OES_mapbuffer() @property { return _GL_OES_mapbuffer; }
enum : uint {
    GL_WRITE_ONLY_OES                 = 0x88B9,
    GL_BUFFER_ACCESS_OES              = 0x88BB,
    GL_BUFFER_MAPPED_OES              = 0x88BC,
    GL_BUFFER_MAP_POINTER_OES         = 0x88BD,
}
extern( System ) nothrow {
    alias da_glMapBufferOES = void* function( GLenum, GLenum );
    alias da_glUnmapBufferOES = GLboolean function( GLenum );
    alias da_glGetBufferPointervOES = void function( GLenum, GLenum, void** );
}
__gshared {
    da_glMapBufferOES glMapBufferOES;
    da_glUnmapBufferOES glUnmapBufferOES;
    da_glGetBufferPointervOES glGetBufferPointervOES;
}
private void load_GL_OES_mapbuffer() {
    try {
        bindGLFunc( cast( void** )&glMapBufferOES, "glMapBufferOES" );
        bindGLFunc( cast( void** )&glUnmapBufferOES, "glUnmapBufferOES" );
        bindGLFunc( cast( void** )&glGetBufferPointervOES, "glGetBufferPointervOES" );

        _GL_OES_mapbuffer = true;
    } catch( Exception e ) {
        _GL_OES_mapbuffer = false;
    }
}

private __gshared bool _GL_OES_packed_depth_stencil;
bool GL_OES_packed_depth_stencil() @property { return _GL_OES_packed_depth_stencil; }
enum : uint {
    GL_DEPTH_STENCIL_OES              = 0x84F9,
    GL_UNSIGNED_INT_24_8_OES          = 0x84FA,
    GL_DEPTH24_STENCIL8_OES           = 0x88F0,
}

private __gshared bool _GL_OES_required_internalformat;
bool GL_OES_required_internalformat() @property { return _GL_OES_required_internalformat; }
enum : uint {
    GL_ALPHA8_OES                     = 0x803C,
    GL_DEPTH_COMPONENT16_OES          = 0x81A5,
    GL_LUMINANCE4_ALPHA4_OES          = 0x8043,
    GL_LUMINANCE8_ALPHA8_OES          = 0x8045,
    GL_LUMINANCE8_OES                 = 0x8040,
    GL_RGBA4_OES                      = 0x8056,
    GL_RGB5_A1_OES                    = 0x8057,
    GL_RGB565_OES                     = 0x8D62,
    GL_RGB8_OES                       = 0x8051,
    GL_RGBA8_OES                      = 0x8058,
    GL_RGB10_EXT                      = 0x8052,
    GL_RGB10_A2_EXT                   = 0x8059,
}

private __gshared bool _GL_OES_rgb8_rgba8;
bool GL_OES_rgb8_rgba8() @property { return _GL_OES_rgb8_rgba8; }

private __gshared bool _GL_OES_sample_shading;
bool GL_OES_sample_shading() @property { return _GL_OES_sample_shading; }
enum : uint {
    GL_SAMPLE_SHADING_OES             = 0x8C36,
    GL_MIN_SAMPLE_SHADING_VALUE_OES   = 0x8C37,
}
extern( System ) nothrow {
    alias da_glMinSampleShadingOES = void function( GLfloat );
}
__gshared {
    da_glMinSampleShadingOES glMinSampleShadingOES;
}
private void load_GL_OES_sample_shading() {
    try {
        bindGLFunc( cast( void** )&glMinSampleShadingOES, "glMinSampleShadingOES" );

        _GL_OES_sample_shading = true;
    } catch( Exception e ) {
        _GL_OES_sample_shading = false;
    }
}

private __gshared bool _GL_OES_sample_variables;
bool GL_OES_sample_variables() @property { return _GL_OES_sample_variables; }

private __gshared bool _GL_OES_shader_image_atomic;
bool GL_OES_shader_image_atomic() @property { return _GL_OES_shader_image_atomic; }

private __gshared bool _GL_OES_shader_multisample_interpolation;
bool GL_OES_shader_multisample_interpolation() @property { return _GL_OES_shader_multisample_interpolation; }
enum : uint {
    GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5B,
    GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5C,
    GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = 0x8E5D,
}

private __gshared bool _GL_OES_standard_derivatives;
bool GL_OES_standard_derivatives() @property { return _GL_OES_standard_derivatives; }
enum : uint {
    GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B,
}

private __gshared bool _GL_OES_stencil1;
bool GL_OES_stencil1() @property { return _GL_OES_stencil1; }
enum : uint {
    GL_STENCIL_INDEX1_OES             = 0x8D46,
}

private __gshared bool _GL_OES_stencil4;
bool GL_OES_stencil4() @property { return _GL_OES_stencil4; }
enum : uint {
    GL_STENCIL_INDEX4_OES             = 0x8D47,
}

private __gshared bool _GL_OES_surfaceless_context;
bool GL_OES_surfaceless_context() @property { return _GL_OES_surfaceless_context; }
enum : uint {
    GL_FRAMEBUFFER_UNDEFINED_OES      = 0x8219,
}

private __gshared bool _GL_OES_texture_3D;
bool GL_OES_texture_3D() @property { return _GL_OES_texture_3D; }
enum : uint {
    GL_TEXTURE_WRAP_R_OES             = 0x8072,
    GL_TEXTURE_3D_OES                 = 0x806F,
    GL_TEXTURE_BINDING_3D_OES         = 0x806A,
    GL_MAX_3D_TEXTURE_SIZE_OES        = 0x8073,
    GL_SAMPLER_3D_OES                 = 0x8B5F,
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = 0x8CD4,
}
extern( System ) nothrow {
    alias da_glTexImage3DOES = void function( GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const void* );
    alias da_glTexSubImage3DOES = void function( GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const void* );
    alias da_glCopyTexSubImage3DOES = void function( GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei );
    alias da_glCompressedTexImage3DOES = void function( GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const void* );
    alias da_glCompressedTexSubImage3DOES = void function( GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const void* );
    alias da_glFramebufferTexture3DOES = void function( GLenum, GLenum, GLenum, GLuint, GLint, GLint );
}
__gshared {
    da_glTexImage3DOES glTexImage3DOES;
    da_glTexSubImage3DOES glTexSubImage3DOES;
    da_glCopyTexSubImage3DOES glCopyTexSubImage3DOES;
    da_glCompressedTexImage3DOES glCompressedTexImage3DOES;
    da_glCompressedTexSubImage3DOES glCompressedTexSubImage3DOES;
    da_glFramebufferTexture3DOES glFramebufferTexture3DOES;
}
private void load_GL_OES_texture_3D() {
    try {
        bindGLFunc( cast( void** )&glTexImage3DOES, "glTexImage3DOES" );
        bindGLFunc( cast( void** )&glTexSubImage3DOES, "glTexSubImage3DOES" );
        bindGLFunc( cast( void** )&glCopyTexSubImage3DOES, "glCopyTexSubImage3DOES" );
        bindGLFunc( cast( void** )&glCompressedTexImage3DOES, "glCompressedTexImage3DOES" );
        bindGLFunc( cast( void** )&glCompressedTexSubImage3DOES, "glCompressedTexSubImage3DOES" );
        bindGLFunc( cast( void** )&glFramebufferTexture3DOES, "glFramebufferTexture3DOES" );

        _GL_OES_texture_3D = true;
    } catch( Exception e ) {
        _GL_OES_texture_3D = false;
    }
}

private __gshared bool _GL_OES_texture_compression_astc;
bool GL_OES_texture_compression_astc() @property { return _GL_OES_texture_compression_astc; }
enum : uint {
    GL_COMPRESSED_RGBA_ASTC_3x3x3_OES = 0x93C0,
    GL_COMPRESSED_RGBA_ASTC_4x3x3_OES = 0x93C1,
    GL_COMPRESSED_RGBA_ASTC_4x4x3_OES = 0x93C2,
    GL_COMPRESSED_RGBA_ASTC_4x4x4_OES = 0x93C3,
    GL_COMPRESSED_RGBA_ASTC_5x4x4_OES = 0x93C4,
    GL_COMPRESSED_RGBA_ASTC_5x5x4_OES = 0x93C5,
    GL_COMPRESSED_RGBA_ASTC_5x5x5_OES = 0x93C6,
    GL_COMPRESSED_RGBA_ASTC_6x5x5_OES = 0x93C7,
    GL_COMPRESSED_RGBA_ASTC_6x6x5_OES = 0x93C8,
    GL_COMPRESSED_RGBA_ASTC_6x6x6_OES = 0x93C9,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = 0x93E0,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = 0x93E1,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = 0x93E2,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = 0x93E3,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = 0x93E4,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = 0x93E5,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = 0x93E6,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = 0x93E7,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = 0x93E8,
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = 0x93E9,
}

private __gshared bool _GL_OES_texture_float;
bool GL_OES_texture_float() @property { return _GL_OES_texture_float; }

private __gshared bool _GL_OES_texture_float_linear;
bool GL_OES_texture_float_linear() @property { return _GL_OES_texture_float_linear; }

private __gshared bool _GL_OES_texture_half_float;
bool GL_OES_texture_half_float() @property { return _GL_OES_texture_half_float; }
enum : uint {
    GL_HALF_FLOAT_OES                 = 0x8D61,
}

private __gshared bool _GL_OES_texture_half_float_linear;
bool GL_OES_texture_half_float_linear() @property { return _GL_OES_texture_half_float_linear; }

private __gshared bool _GL_OES_texture_npot;
bool GL_OES_texture_npot() @property { return _GL_OES_texture_npot; }

private __gshared bool _GL_OES_texture_stencil8;
bool GL_OES_texture_stencil8() @property { return _GL_OES_texture_stencil8; }
enum : uint {
    GL_STENCIL_INDEX_OES              = 0x1901,
    GL_STENCIL_INDEX8_OES             = 0x8D48,
}

private __gshared bool _GL_OES_texture_storage_multisample_2d_array;
bool GL_OES_texture_storage_multisample_2d_array() @property { return _GL_OES_texture_storage_multisample_2d_array; }
enum : uint {
    GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES = 0x9102,
    GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = 0x9105,
    GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910B,
    GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910C,
    GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910D,
}
extern( System ) nothrow {
    alias da_glTexStorage3DMultisampleOES = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean );
}
__gshared {
    da_glTexStorage3DMultisampleOES glTexStorage3DMultisampleOES;
}
private void load_GL_OES_texture_storage_multisample_2d_array() {
    try {
        bindGLFunc( cast( void** )&glTexStorage3DMultisampleOES, "glTexStorage3DMultisampleOES" );

        _GL_OES_texture_storage_multisample_2d_array = true;
    } catch( Exception e ) {
        _GL_OES_texture_storage_multisample_2d_array = false;
    }
}

private __gshared bool _GL_OES_vertex_array_object;
bool GL_OES_vertex_array_object() @property { return _GL_OES_vertex_array_object; }
enum : uint {
    GL_VERTEX_ARRAY_BINDING_OES       = 0x85B5,
}
extern( System ) nothrow {
    alias da_glBindVertexArrayOES = void function( GLuint );
    alias da_glDeleteVertexArraysOES = void function( GLsizei, const GLuint* );
    alias da_glGenVertexArraysOES = void function( GLsizei, GLuint* );
    alias da_glIsVertexArrayOES = GLboolean function( GLuint );
}
__gshared {
    da_glBindVertexArrayOES glBindVertexArrayOES;
    da_glDeleteVertexArraysOES glDeleteVertexArraysOES;
    da_glGenVertexArraysOES glGenVertexArraysOES;
    da_glIsVertexArrayOES glIsVertexArrayOES;
}
private void load_GL_OES_vertex_array_object() {
    try {
        bindGLFunc( cast( void** )&glBindVertexArrayOES, "glBindVertexArrayOES" );
        bindGLFunc( cast( void** )&glDeleteVertexArraysOES, "glDeleteVertexArraysOES" );
        bindGLFunc( cast( void** )&glGenVertexArraysOES, "glGenVertexArraysOES" );
        bindGLFunc( cast( void** )&glIsVertexArrayOES, "glIsVertexArrayOES" );

        _GL_OES_vertex_array_object = true;
    } catch( Exception e ) {
        _GL_OES_vertex_array_object = false;
    }
}

private __gshared bool _GL_OES_vertex_half_float;
bool GL_OES_vertex_half_float() @property { return _GL_OES_vertex_half_float; }

private __gshared bool _GL_OES_vertex_type_10_10_10_2;
bool GL_OES_vertex_type_10_10_10_2() @property { return _GL_OES_vertex_type_10_10_10_2; }
enum : uint {
    GL_UNSIGNED_INT_10_10_10_2_OES    = 0x8DF6,
    GL_INT_10_10_10_2_OES             = 0x8DF7,
}

private __gshared bool _GL_AMD_compressed_3DC_texture;
bool GL_AMD_compressed_3DC_texture() @property { return _GL_AMD_compressed_3DC_texture; }
enum : uint {
    GL_3DC_X_AMD                      = 0x87F9,
    GL_3DC_XY_AMD                     = 0x87FA,
}

private __gshared bool _GL_AMD_compressed_ATC_texture;
bool GL_AMD_compressed_ATC_texture() @property { return _GL_AMD_compressed_ATC_texture; }
enum : uint {
    GL_ATC_RGB_AMD                    = 0x8C92,
    GL_ATC_RGBA_EXPLICIT_ALPHA_AMD    = 0x8C93,
    GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD = 0x87EE,
}

private __gshared bool _GL_AMD_performance_monitor;
bool GL_AMD_performance_monitor() @property { return _GL_AMD_performance_monitor; }
enum : uint {
    GL_COUNTER_TYPE_AMD               = 0x8BC0,
    GL_COUNTER_RANGE_AMD              = 0x8BC1,
    GL_UNSIGNED_INT64_AMD             = 0x8BC2,
    GL_PERCENTAGE_AMD                 = 0x8BC3,
    GL_PERFMON_RESULT_AVAILABLE_AMD   = 0x8BC4,
    GL_PERFMON_RESULT_SIZE_AMD        = 0x8BC5,
    GL_PERFMON_RESULT_AMD             = 0x8BC6,
}
extern( System ) nothrow {
    alias da_glGetPerfMonitorGroupsAMD = void function( GLint*, GLsizei, GLuint* );
    alias da_glGetPerfMonitorCountersAMD = void function( GLuint, GLint*, GLint*, GLsizei, GLuint* );
    alias da_glGetPerfMonitorGroupStringAMD = void function( GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glGetPerfMonitorCounterStringAMD = void function( GLuint, GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glGetPerfMonitorCounterInfoAMD = void function( GLuint, GLuint, GLenum, void* );
    alias da_glGenPerfMonitorsAMD = void function( GLsizei, GLuint* );
    alias da_glDeletePerfMonitorsAMD = void function( GLsizei, GLuint* );
    alias da_glSelectPerfMonitorCountersAMD = void function( GLuint, GLboolean, GLuint, GLint, GLuint* );
    alias da_glBeginPerfMonitorAMD = void function( GLuint );
    alias da_glEndPerfMonitorAMD = void function( GLuint );
    alias da_glGetPerfMonitorCounterDataAMD = void function( GLuint, GLenum, GLsizei, GLuint*, GLint* );
}
__gshared {
    da_glGetPerfMonitorGroupsAMD glGetPerfMonitorGroupsAMD;
    da_glGetPerfMonitorCountersAMD glGetPerfMonitorCountersAMD;
    da_glGetPerfMonitorGroupStringAMD glGetPerfMonitorGroupStringAMD;
    da_glGetPerfMonitorCounterStringAMD glGetPerfMonitorCounterStringAMD;
    da_glGetPerfMonitorCounterInfoAMD glGetPerfMonitorCounterInfoAMD;
    da_glGenPerfMonitorsAMD glGenPerfMonitorsAMD;
    da_glDeletePerfMonitorsAMD glDeletePerfMonitorsAMD;
    da_glSelectPerfMonitorCountersAMD glSelectPerfMonitorCountersAMD;
    da_glBeginPerfMonitorAMD glBeginPerfMonitorAMD;
    da_glEndPerfMonitorAMD glEndPerfMonitorAMD;
    da_glGetPerfMonitorCounterDataAMD glGetPerfMonitorCounterDataAMD;
}
private void load_GL_AMD_performance_monitor() {
    try {
        bindGLFunc( cast( void** )&glGetPerfMonitorGroupsAMD, "glGetPerfMonitorGroupsAMD" );
        bindGLFunc( cast( void** )&glGetPerfMonitorCountersAMD, "glGetPerfMonitorCountersAMD" );
        bindGLFunc( cast( void** )&glGetPerfMonitorGroupStringAMD, "glGetPerfMonitorGroupStringAMD" );
        bindGLFunc( cast( void** )&glGetPerfMonitorCounterStringAMD, "glGetPerfMonitorCounterStringAMD" );
        bindGLFunc( cast( void** )&glGetPerfMonitorCounterInfoAMD, "glGetPerfMonitorCounterInfoAMD" );
        bindGLFunc( cast( void** )&glGenPerfMonitorsAMD, "glGenPerfMonitorsAMD" );
        bindGLFunc( cast( void** )&glDeletePerfMonitorsAMD, "glDeletePerfMonitorsAMD" );
        bindGLFunc( cast( void** )&glSelectPerfMonitorCountersAMD, "glSelectPerfMonitorCountersAMD" );
        bindGLFunc( cast( void** )&glBeginPerfMonitorAMD, "glBeginPerfMonitorAMD" );
        bindGLFunc( cast( void** )&glEndPerfMonitorAMD, "glEndPerfMonitorAMD" );
        bindGLFunc( cast( void** )&glGetPerfMonitorCounterDataAMD, "glGetPerfMonitorCounterDataAMD" );

        _GL_AMD_performance_monitor = true;
    } catch( Exception e ) {
        _GL_AMD_performance_monitor = false;
    }
}

private __gshared bool _GL_AMD_program_binary_Z400;
bool GL_AMD_program_binary_Z400() @property { return _GL_AMD_program_binary_Z400; }
enum : uint {
    GL_Z400_BINARY_AMD                = 0x8740,
}

private __gshared bool _GL_ANGLE_depth_texture;
bool GL_ANGLE_depth_texture() @property { return _GL_ANGLE_depth_texture; }

private __gshared bool _GL_ANGLE_framebuffer_blit;
bool GL_ANGLE_framebuffer_blit() @property { return _GL_ANGLE_framebuffer_blit; }
enum : uint {
    GL_READ_FRAMEBUFFER_ANGLE         = 0x8CA8,
    GL_DRAW_FRAMEBUFFER_ANGLE         = 0x8CA9,
    GL_DRAW_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6,
    GL_READ_FRAMEBUFFER_BINDING_ANGLE = 0x8CAA,
}
extern( System ) nothrow {
    alias da_glBlitFramebufferANGLE = void function( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield, GLenum );
}
__gshared {
    da_glBlitFramebufferANGLE glBlitFramebufferANGLE;
}
private void load_GL_ANGLE_framebuffer_blit() {
    try {
        bindGLFunc( cast( void** )&glBlitFramebufferANGLE, "glBlitFramebufferANGLE" );

        _GL_ANGLE_framebuffer_blit = true;
    } catch( Exception e ) {
        _GL_ANGLE_framebuffer_blit = false;
    }
}

private __gshared bool _GL_ANGLE_framebuffer_multisample;
bool GL_ANGLE_framebuffer_multisample() @property { return _GL_ANGLE_framebuffer_multisample; }
enum : uint {
    GL_RENDERBUFFER_SAMPLES_ANGLE     = 0x8CAB,
    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = 0x8D56,
    GL_MAX_SAMPLES_ANGLE              = 0x8D57,
}
extern( System ) nothrow {
    alias da_glRenderbufferStorageMultisampleANGLE = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei );
}
__gshared {
    da_glRenderbufferStorageMultisampleANGLE glRenderbufferStorageMultisampleANGLE;
}
private void load_GL_ANGLE_framebuffer_multisample() {
    try {
        bindGLFunc( cast( void** )&glRenderbufferStorageMultisampleANGLE, "glRenderbufferStorageMultisampleANGLE" );

        _GL_ANGLE_framebuffer_multisample = true;
    } catch( Exception e ) {
        _GL_ANGLE_framebuffer_multisample = false;
    }
}

private __gshared bool _GL_ANGLE_instanced_arrays;
bool GL_ANGLE_instanced_arrays() @property { return _GL_ANGLE_instanced_arrays; }
enum : uint {
    GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE,
}
extern( System ) nothrow {
    alias da_glDrawArraysInstancedANGLE = void function( GLenum, GLint, GLsizei, GLsizei );
    alias da_glDrawElementsInstancedANGLE = void function( GLenum, GLsizei, GLenum, const void*, GLsizei );
    alias da_glVertexAttribDivisorANGLE = void function( GLuint, GLuint );
}
__gshared {
    da_glDrawArraysInstancedANGLE glDrawArraysInstancedANGLE;
    da_glDrawElementsInstancedANGLE glDrawElementsInstancedANGLE;
    da_glVertexAttribDivisorANGLE glVertexAttribDivisorANGLE;
}
private void load_GL_ANGLE_instanced_arrays() {
    try {
        bindGLFunc( cast( void** )&glDrawArraysInstancedANGLE, "glDrawArraysInstancedANGLE" );
        bindGLFunc( cast( void** )&glDrawElementsInstancedANGLE, "glDrawElementsInstancedANGLE" );
        bindGLFunc( cast( void** )&glVertexAttribDivisorANGLE, "glVertexAttribDivisorANGLE" );

        _GL_ANGLE_instanced_arrays = true;
    } catch( Exception e ) {
        _GL_ANGLE_instanced_arrays = false;
    }
}

private __gshared bool _GL_ANGLE_pack_reverse_row_order;
bool GL_ANGLE_pack_reverse_row_order() @property { return _GL_ANGLE_pack_reverse_row_order; }
enum : uint {
    GL_PACK_REVERSE_ROW_ORDER_ANGLE   = 0x93A4,
}

private __gshared bool _GL_ANGLE_program_binary;
bool GL_ANGLE_program_binary() @property { return _GL_ANGLE_program_binary; }
enum : uint {
    GL_PROGRAM_BINARY_ANGLE           = 0x93A6,
}

private __gshared bool _GL_ANGLE_texture_compression_dxt3;
bool GL_ANGLE_texture_compression_dxt3() @property { return _GL_ANGLE_texture_compression_dxt3; }
enum : uint {
    GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE = 0x83F2,
}

private __gshared bool _GL_ANGLE_texture_compression_dxt5;
bool GL_ANGLE_texture_compression_dxt5() @property { return _GL_ANGLE_texture_compression_dxt5; }
enum : uint {
    GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE = 0x83F3,
}

private __gshared bool _GL_ANGLE_texture_usage;
bool GL_ANGLE_texture_usage() @property { return _GL_ANGLE_texture_usage; }
enum : uint {
    GL_TEXTURE_USAGE_ANGLE            = 0x93A2,
    GL_FRAMEBUFFER_ATTACHMENT_ANGLE   = 0x93A3,
}

private __gshared bool _GL_ANGLE_translated_shader_source;
bool GL_ANGLE_translated_shader_source() @property { return _GL_ANGLE_translated_shader_source; }
enum : uint {
    GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = 0x93A0,
}
extern( System ) nothrow {
    alias da_glGetTranslatedShaderSourceANGLE = void function( GLuint, GLsizei, GLsizei*, GLchar* );
}
__gshared {
    da_glGetTranslatedShaderSourceANGLE glGetTranslatedShaderSourceANGLE;
}
private void load_GL_ANGLE_translated_shader_source() {
    try {
        bindGLFunc( cast( void** )&glGetTranslatedShaderSourceANGLE, "glGetTranslatedShaderSourceANGLE" );

        _GL_ANGLE_translated_shader_source = true;
    } catch( Exception e ) {
        _GL_ANGLE_translated_shader_source = false;
    }
}

private __gshared bool _GL_APPLE_copy_texture_levels;
bool GL_APPLE_copy_texture_levels() @property { return _GL_APPLE_copy_texture_levels; }
extern( System ) nothrow {
    alias da_glCopyTextureLevelsAPPLE = void function( GLuint, GLuint, GLint, GLsizei );
}
__gshared {
    da_glCopyTextureLevelsAPPLE glCopyTextureLevelsAPPLE;
}
private void load_GL_APPLE_copy_texture_levels() {
    try {
        bindGLFunc( cast( void** )&glCopyTextureLevelsAPPLE, "glCopyTextureLevelsAPPLE" );

        _GL_APPLE_copy_texture_levels = true;
    } catch( Exception e ) {
        _GL_APPLE_copy_texture_levels = false;
    }
}

private __gshared bool _GL_APPLE_framebuffer_multisample;
bool GL_APPLE_framebuffer_multisample() @property { return _GL_APPLE_framebuffer_multisample; }
enum : uint {
    GL_RENDERBUFFER_SAMPLES_APPLE     = 0x8CAB,
    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = 0x8D56,
    GL_MAX_SAMPLES_APPLE              = 0x8D57,
    GL_READ_FRAMEBUFFER_APPLE         = 0x8CA8,
    GL_DRAW_FRAMEBUFFER_APPLE         = 0x8CA9,
    GL_DRAW_FRAMEBUFFER_BINDING_APPLE = 0x8CA6,
    GL_READ_FRAMEBUFFER_BINDING_APPLE = 0x8CAA,
}
extern( System ) nothrow {
    alias da_glRenderbufferStorageMultisampleAPPLE = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei );
    alias da_glResolveMultisampleFramebufferAPPLE = void function(  );
}
__gshared {
    da_glRenderbufferStorageMultisampleAPPLE glRenderbufferStorageMultisampleAPPLE;
    da_glResolveMultisampleFramebufferAPPLE glResolveMultisampleFramebufferAPPLE;
}
private void load_GL_APPLE_framebuffer_multisample() {
    try {
        bindGLFunc( cast( void** )&glRenderbufferStorageMultisampleAPPLE, "glRenderbufferStorageMultisampleAPPLE" );
        bindGLFunc( cast( void** )&glResolveMultisampleFramebufferAPPLE, "glResolveMultisampleFramebufferAPPLE" );

        _GL_APPLE_framebuffer_multisample = true;
    } catch( Exception e ) {
        _GL_APPLE_framebuffer_multisample = false;
    }
}

private __gshared bool _GL_APPLE_rgb_422;
bool GL_APPLE_rgb_422() @property { return _GL_APPLE_rgb_422; }
enum : uint {
    GL_RGB_422_APPLE                  = 0x8A1F,
    GL_UNSIGNED_SHORT_8_8_APPLE       = 0x85BA,
    GL_UNSIGNED_SHORT_8_8_REV_APPLE   = 0x85BB,
    GL_RGB_RAW_422_APPLE              = 0x8A51,
}

private __gshared bool _GL_APPLE_sync;
bool GL_APPLE_sync() @property { return _GL_APPLE_sync; }
enum : ulong {
    GL_SYNC_OBJECT_APPLE              = 0x8A53,
    GL_MAX_SERVER_WAIT_TIMEOUT_APPLE  = 0x9111,
    GL_OBJECT_TYPE_APPLE              = 0x9112,
    GL_SYNC_CONDITION_APPLE           = 0x9113,
    GL_SYNC_STATUS_APPLE              = 0x9114,
    GL_SYNC_FLAGS_APPLE               = 0x9115,
    GL_SYNC_FENCE_APPLE               = 0x9116,
    GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE = 0x9117,
    GL_UNSIGNALED_APPLE               = 0x9118,
    GL_SIGNALED_APPLE                 = 0x9119,
    GL_ALREADY_SIGNALED_APPLE         = 0x911A,
    GL_TIMEOUT_EXPIRED_APPLE          = 0x911B,
    GL_CONDITION_SATISFIED_APPLE      = 0x911C,
    GL_WAIT_FAILED_APPLE              = 0x911D,
    GL_SYNC_FLUSH_COMMANDS_BIT_APPLE  = 0x00000001,
    GL_TIMEOUT_IGNORED_APPLE          = 0xFFFFFFFFFFFFFFFFU,
}
extern( System ) nothrow {
    alias da_glFenceSyncAPPLE = GLsync function( GLenum, GLbitfield );
    alias da_glIsSyncAPPLE = GLboolean function( GLsync );
    alias da_glDeleteSyncAPPLE = void function( GLsync );
    alias da_glClientWaitSyncAPPLE = GLenum function( GLsync, GLbitfield, GLuint64 );
    alias da_glWaitSyncAPPLE = void function( GLsync, GLbitfield, GLuint64 );
    alias da_glGetInteger64vAPPLE = void function( GLenum, GLint64* );
    alias da_glGetSyncivAPPLE = void function( GLsync, GLenum, GLsizei, GLsizei*, GLint* );
}
__gshared {
    da_glFenceSyncAPPLE glFenceSyncAPPLE;
    da_glIsSyncAPPLE glIsSyncAPPLE;
    da_glDeleteSyncAPPLE glDeleteSyncAPPLE;
    da_glClientWaitSyncAPPLE glClientWaitSyncAPPLE;
    da_glWaitSyncAPPLE glWaitSyncAPPLE;
    da_glGetInteger64vAPPLE glGetInteger64vAPPLE;
    da_glGetSyncivAPPLE glGetSyncivAPPLE;
}
private void load_GL_APPLE_sync() {
    try {
        bindGLFunc( cast( void** )&glFenceSyncAPPLE, "glFenceSyncAPPLE" );
        bindGLFunc( cast( void** )&glIsSyncAPPLE, "glIsSyncAPPLE" );
        bindGLFunc( cast( void** )&glDeleteSyncAPPLE, "glDeleteSyncAPPLE" );
        bindGLFunc( cast( void** )&glClientWaitSyncAPPLE, "glClientWaitSyncAPPLE" );
        bindGLFunc( cast( void** )&glWaitSyncAPPLE, "glWaitSyncAPPLE" );
        bindGLFunc( cast( void** )&glGetInteger64vAPPLE, "glGetInteger64vAPPLE" );
        bindGLFunc( cast( void** )&glGetSyncivAPPLE, "glGetSyncivAPPLE" );

        _GL_APPLE_sync = true;
    } catch( Exception e ) {
        _GL_APPLE_sync = false;
    }
}

private __gshared bool _GL_APPLE_texture_format_BGRA8888;
bool GL_APPLE_texture_format_BGRA8888() @property { return _GL_APPLE_texture_format_BGRA8888; }
enum : uint {
    GL_BGRA_EXT                       = 0x80E1,
    GL_BGRA8_EXT                      = 0x93A1,
}

private __gshared bool _GL_APPLE_texture_max_level;
bool GL_APPLE_texture_max_level() @property { return _GL_APPLE_texture_max_level; }
enum : uint {
    GL_TEXTURE_MAX_LEVEL_APPLE        = 0x813D,
}

private __gshared bool _GL_ARM_mali_program_binary;
bool GL_ARM_mali_program_binary() @property { return _GL_ARM_mali_program_binary; }
enum : uint {
    GL_MALI_PROGRAM_BINARY_ARM        = 0x8F61,
}

private __gshared bool _GL_ARM_mali_shader_binary;
bool GL_ARM_mali_shader_binary() @property { return _GL_ARM_mali_shader_binary; }
enum : uint {
    GL_MALI_SHADER_BINARY_ARM         = 0x8F60,
}

private __gshared bool _GL_ARM_rgba8;
bool GL_ARM_rgba8() @property { return _GL_ARM_rgba8; }

private __gshared bool _GL_ARM_shader_framebuffer_fetch;
bool GL_ARM_shader_framebuffer_fetch() @property { return _GL_ARM_shader_framebuffer_fetch; }
enum : uint {
    GL_FETCH_PER_SAMPLE_ARM           = 0x8F65,
    GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = 0x8F66,
}

private __gshared bool _GL_ARM_shader_framebuffer_fetch_depth_stencil;
bool GL_ARM_shader_framebuffer_fetch_depth_stencil() @property { return _GL_ARM_shader_framebuffer_fetch_depth_stencil; }

private __gshared bool _GL_DMP_shader_binary;
bool GL_DMP_shader_binary() @property { return _GL_DMP_shader_binary; }
enum : uint {
    GL_SHADER_BINARY_DMP              = 0x9250,
}

private __gshared bool _GL_EXT_blend_minmax;
bool GL_EXT_blend_minmax() @property { return _GL_EXT_blend_minmax; }
enum : uint {
    GL_MIN_EXT                        = 0x8007,
    GL_MAX_EXT                        = 0x8008,
}

private __gshared bool _GL_EXT_color_buffer_half_float;
bool GL_EXT_color_buffer_half_float() @property { return _GL_EXT_color_buffer_half_float; }
enum : uint {
    GL_RGBA16F_EXT                    = 0x881A,
    GL_RGB16F_EXT                     = 0x881B,
    GL_RG16F_EXT                      = 0x822F,
    GL_R16F_EXT                       = 0x822D,
    GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x8211,
    GL_UNSIGNED_NORMALIZED_EXT        = 0x8C17,
}

private __gshared bool _GL_EXT_debug_label;
bool GL_EXT_debug_label() @property { return _GL_EXT_debug_label; }
enum : uint {
    GL_PROGRAM_PIPELINE_OBJECT_EXT    = 0x8A4F,
    GL_PROGRAM_OBJECT_EXT             = 0x8B40,
    GL_SHADER_OBJECT_EXT              = 0x8B48,
    GL_BUFFER_OBJECT_EXT              = 0x9151,
    GL_QUERY_OBJECT_EXT               = 0x9153,
    GL_VERTEX_ARRAY_OBJECT_EXT        = 0x9154,
    GL_TRANSFORM_FEEDBACK             = 0x8E22,
}
extern( System ) nothrow {
    alias da_glLabelObjectEXT = void function( GLenum, GLuint, GLsizei, const GLchar* );
    alias da_glGetObjectLabelEXT = void function( GLenum, GLuint, GLsizei, GLsizei*, GLchar* );
}
__gshared {
    da_glLabelObjectEXT glLabelObjectEXT;
    da_glGetObjectLabelEXT glGetObjectLabelEXT;
}
private void load_GL_EXT_debug_label() {
    try {
        bindGLFunc( cast( void** )&glLabelObjectEXT, "glLabelObjectEXT" );
        bindGLFunc( cast( void** )&glGetObjectLabelEXT, "glGetObjectLabelEXT" );

        _GL_EXT_debug_label = true;
    } catch( Exception e ) {
        _GL_EXT_debug_label = false;
    }
}

private __gshared bool _GL_EXT_debug_marker;
bool GL_EXT_debug_marker() @property { return _GL_EXT_debug_marker; }
extern( System ) nothrow {
    alias da_glInsertEventMarkerEXT = void function( GLsizei, const GLchar* );
    alias da_glPushGroupMarkerEXT = void function( GLsizei, const GLchar* );
    alias da_glPopGroupMarkerEXT = void function(  );
}
__gshared {
    da_glInsertEventMarkerEXT glInsertEventMarkerEXT;
    da_glPushGroupMarkerEXT glPushGroupMarkerEXT;
    da_glPopGroupMarkerEXT glPopGroupMarkerEXT;
}
private void load_GL_EXT_debug_marker() {
    try {
        bindGLFunc( cast( void** )&glInsertEventMarkerEXT, "glInsertEventMarkerEXT" );
        bindGLFunc( cast( void** )&glPushGroupMarkerEXT, "glPushGroupMarkerEXT" );
        bindGLFunc( cast( void** )&glPopGroupMarkerEXT, "glPopGroupMarkerEXT" );

        _GL_EXT_debug_marker = true;
    } catch( Exception e ) {
        _GL_EXT_debug_marker = false;
    }
}

private __gshared bool _GL_EXT_discard_framebuffer;
bool GL_EXT_discard_framebuffer() @property { return _GL_EXT_discard_framebuffer; }
enum : uint {
    GL_COLOR_EXT                      = 0x1800,
    GL_DEPTH_EXT                      = 0x1801,
    GL_STENCIL_EXT                    = 0x1802,
}
extern( System ) nothrow {
    alias da_glDiscardFramebufferEXT = void function( GLenum, GLsizei, const GLenum* );
}
__gshared {
    da_glDiscardFramebufferEXT glDiscardFramebufferEXT;
}
private void load_GL_EXT_discard_framebuffer() {
    try {
        bindGLFunc( cast( void** )&glDiscardFramebufferEXT, "glDiscardFramebufferEXT" );

        _GL_EXT_discard_framebuffer = true;
    } catch( Exception e ) {
        _GL_EXT_discard_framebuffer = false;
    }
}

private __gshared bool _GL_EXT_disjoint_timer_query;
bool GL_EXT_disjoint_timer_query() @property { return _GL_EXT_disjoint_timer_query; }
enum : uint {
    GL_QUERY_COUNTER_BITS_EXT         = 0x8864,
    GL_CURRENT_QUERY_EXT              = 0x8865,
    GL_QUERY_RESULT_EXT               = 0x8866,
    GL_QUERY_RESULT_AVAILABLE_EXT     = 0x8867,
    GL_TIME_ELAPSED_EXT               = 0x88BF,
    GL_TIMESTAMP_EXT                  = 0x8E28,
    GL_GPU_DISJOINT_EXT               = 0x8FBB,
}
extern( System ) nothrow {
    alias da_glGenQueriesEXT = void function( GLsizei, GLuint* );
    alias da_glDeleteQueriesEXT = void function( GLsizei, const GLuint* );
    alias da_glIsQueryEXT = GLboolean function( GLuint );
    alias da_glBeginQueryEXT = void function( GLenum, GLuint );
    alias da_glEndQueryEXT = void function( GLenum );
    alias da_glQueryCounterEXT = void function( GLuint, GLenum );
    alias da_glGetQueryivEXT = void function( GLenum, GLenum, GLint* );
    alias da_glGetQueryObjectivEXT = void function( GLuint, GLenum, GLint* );
    alias da_glGetQueryObjectuivEXT = void function( GLuint, GLenum, GLuint* );
    alias da_glGetQueryObjecti64vEXT = void function( GLuint, GLenum, GLint64* );
    alias da_glGetQueryObjectui64vEXT = void function( GLuint, GLenum, GLuint64* );
}
__gshared {
    da_glGenQueriesEXT glGenQueriesEXT;
    da_glDeleteQueriesEXT glDeleteQueriesEXT;
    da_glIsQueryEXT glIsQueryEXT;
    da_glBeginQueryEXT glBeginQueryEXT;
    da_glEndQueryEXT glEndQueryEXT;
    da_glQueryCounterEXT glQueryCounterEXT;
    da_glGetQueryivEXT glGetQueryivEXT;
    da_glGetQueryObjectivEXT glGetQueryObjectivEXT;
    da_glGetQueryObjectuivEXT glGetQueryObjectuivEXT;
    da_glGetQueryObjecti64vEXT glGetQueryObjecti64vEXT;
    da_glGetQueryObjectui64vEXT glGetQueryObjectui64vEXT;
}
private void load_GL_EXT_disjoint_timer_query() {
    try {
        bindGLFunc( cast( void** )&glGenQueriesEXT, "glGenQueriesEXT" );
        bindGLFunc( cast( void** )&glDeleteQueriesEXT, "glDeleteQueriesEXT" );
        bindGLFunc( cast( void** )&glIsQueryEXT, "glIsQueryEXT" );
        bindGLFunc( cast( void** )&glBeginQueryEXT, "glBeginQueryEXT" );
        bindGLFunc( cast( void** )&glEndQueryEXT, "glEndQueryEXT" );
        bindGLFunc( cast( void** )&glQueryCounterEXT, "glQueryCounterEXT" );
        bindGLFunc( cast( void** )&glGetQueryivEXT, "glGetQueryivEXT" );
        bindGLFunc( cast( void** )&glGetQueryObjectivEXT, "glGetQueryObjectivEXT" );
        bindGLFunc( cast( void** )&glGetQueryObjectuivEXT, "glGetQueryObjectuivEXT" );
        bindGLFunc( cast( void** )&glGetQueryObjecti64vEXT, "glGetQueryObjecti64vEXT" );
        bindGLFunc( cast( void** )&glGetQueryObjectui64vEXT, "glGetQueryObjectui64vEXT" );

        _GL_EXT_disjoint_timer_query = true;
    } catch( Exception e ) {
        _GL_EXT_disjoint_timer_query = false;
    }
}

private __gshared bool _GL_EXT_draw_buffers;
bool GL_EXT_draw_buffers() @property { return _GL_EXT_draw_buffers; }
enum : uint {
    GL_MAX_COLOR_ATTACHMENTS_EXT      = 0x8CDF,
    GL_MAX_DRAW_BUFFERS_EXT           = 0x8824,
    GL_DRAW_BUFFER0_EXT               = 0x8825,
    GL_DRAW_BUFFER1_EXT               = 0x8826,
    GL_DRAW_BUFFER2_EXT               = 0x8827,
    GL_DRAW_BUFFER3_EXT               = 0x8828,
    GL_DRAW_BUFFER4_EXT               = 0x8829,
    GL_DRAW_BUFFER5_EXT               = 0x882A,
    GL_DRAW_BUFFER6_EXT               = 0x882B,
    GL_DRAW_BUFFER7_EXT               = 0x882C,
    GL_DRAW_BUFFER8_EXT               = 0x882D,
    GL_DRAW_BUFFER9_EXT               = 0x882E,
    GL_DRAW_BUFFER10_EXT              = 0x882F,
    GL_DRAW_BUFFER11_EXT              = 0x8830,
    GL_DRAW_BUFFER12_EXT              = 0x8831,
    GL_DRAW_BUFFER13_EXT              = 0x8832,
    GL_DRAW_BUFFER14_EXT              = 0x8833,
    GL_DRAW_BUFFER15_EXT              = 0x8834,
    GL_COLOR_ATTACHMENT0_EXT          = 0x8CE0,
    GL_COLOR_ATTACHMENT1_EXT          = 0x8CE1,
    GL_COLOR_ATTACHMENT2_EXT          = 0x8CE2,
    GL_COLOR_ATTACHMENT3_EXT          = 0x8CE3,
    GL_COLOR_ATTACHMENT4_EXT          = 0x8CE4,
    GL_COLOR_ATTACHMENT5_EXT          = 0x8CE5,
    GL_COLOR_ATTACHMENT6_EXT          = 0x8CE6,
    GL_COLOR_ATTACHMENT7_EXT          = 0x8CE7,
    GL_COLOR_ATTACHMENT8_EXT          = 0x8CE8,
    GL_COLOR_ATTACHMENT9_EXT          = 0x8CE9,
    GL_COLOR_ATTACHMENT10_EXT         = 0x8CEA,
    GL_COLOR_ATTACHMENT11_EXT         = 0x8CEB,
    GL_COLOR_ATTACHMENT12_EXT         = 0x8CEC,
    GL_COLOR_ATTACHMENT13_EXT         = 0x8CED,
    GL_COLOR_ATTACHMENT14_EXT         = 0x8CEE,
    GL_COLOR_ATTACHMENT15_EXT         = 0x8CEF,
}
extern( System ) nothrow {
    alias da_glDrawBuffersEXT = void function( GLsizei, const GLenum* );
}
__gshared {
    da_glDrawBuffersEXT glDrawBuffersEXT;
}
private void load_GL_EXT_draw_buffers() {
    try {
        bindGLFunc( cast( void** )&glDrawBuffersEXT, "glDrawBuffersEXT" );

        _GL_EXT_draw_buffers = true;
    } catch( Exception e ) {
        _GL_EXT_draw_buffers = false;
    }
}

private __gshared bool _GL_EXT_draw_instanced;
bool GL_EXT_draw_instanced() @property { return _GL_EXT_draw_instanced; }
extern( System ) nothrow {
    alias da_glDrawArraysInstancedEXT = void function( GLenum, GLint, GLsizei, GLsizei );
    alias da_glDrawElementsInstancedEXT = void function( GLenum, GLsizei, GLenum, const void*, GLsizei );
}
__gshared {
    da_glDrawArraysInstancedEXT glDrawArraysInstancedEXT;
    da_glDrawElementsInstancedEXT glDrawElementsInstancedEXT;
}
private void load_GL_EXT_draw_instanced() {
    try {
        bindGLFunc( cast( void** )&glDrawArraysInstancedEXT, "glDrawArraysInstancedEXT" );
        bindGLFunc( cast( void** )&glDrawElementsInstancedEXT, "glDrawElementsInstancedEXT" );

        _GL_EXT_draw_instanced = true;
    } catch( Exception e ) {
        _GL_EXT_draw_instanced = false;
    }
}

private __gshared bool _GL_EXT_instanced_arrays;
bool GL_EXT_instanced_arrays() @property { return _GL_EXT_instanced_arrays; }
enum : uint {
    GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = 0x88FE,
}
extern( System ) nothrow {
    alias da_glVertexAttribDivisorEXT = void function( GLuint, GLuint );
}
__gshared {
    da_glVertexAttribDivisorEXT glVertexAttribDivisorEXT;
}
private void load_GL_EXT_instanced_arrays() {
    try {
        bindGLFunc( cast( void** )&glVertexAttribDivisorEXT, "glVertexAttribDivisorEXT" );

        _GL_EXT_instanced_arrays = true;
    } catch( Exception e ) {
        _GL_EXT_instanced_arrays = false;
    }
}

private __gshared bool _GL_EXT_map_buffer_range;
bool GL_EXT_map_buffer_range() @property { return _GL_EXT_map_buffer_range; }
enum : uint {
    GL_MAP_READ_BIT_EXT               = 0x0001,
    GL_MAP_WRITE_BIT_EXT              = 0x0002,
    GL_MAP_INVALIDATE_RANGE_BIT_EXT   = 0x0004,
    GL_MAP_INVALIDATE_BUFFER_BIT_EXT  = 0x0008,
    GL_MAP_FLUSH_EXPLICIT_BIT_EXT     = 0x0010,
    GL_MAP_UNSYNCHRONIZED_BIT_EXT     = 0x0020,
}
extern( System ) nothrow {
    alias da_glMapBufferRangeEXT = void* function( GLenum, GLintptr, GLsizeiptr, GLbitfield );
    alias da_glFlushMappedBufferRangeEXT = void function( GLenum, GLintptr, GLsizeiptr );
}
__gshared {
    da_glMapBufferRangeEXT glMapBufferRangeEXT;
    da_glFlushMappedBufferRangeEXT glFlushMappedBufferRangeEXT;
}
private void load_GL_EXT_map_buffer_range() {
    try {
        bindGLFunc( cast( void** )&glMapBufferRangeEXT, "glMapBufferRangeEXT" );
        bindGLFunc( cast( void** )&glFlushMappedBufferRangeEXT, "glFlushMappedBufferRangeEXT" );

        _GL_EXT_map_buffer_range = true;
    } catch( Exception e ) {
        _GL_EXT_map_buffer_range = false;
    }
}

private __gshared bool _GL_EXT_multi_draw_arrays;
bool GL_EXT_multi_draw_arrays() @property { return _GL_EXT_multi_draw_arrays; }
extern( System ) nothrow {
    alias da_glMultiDrawArraysEXT = void function( GLenum, const GLint*, const GLsizei*, GLsizei );
    alias da_glMultiDrawElementsEXT = void function( GLenum, const GLsizei*, GLenum, const( const( void )* )*, GLsizei );
}
__gshared {
    da_glMultiDrawArraysEXT glMultiDrawArraysEXT;
    da_glMultiDrawElementsEXT glMultiDrawElementsEXT;
}
private void load_GL_EXT_multi_draw_arrays() {
    try {
        bindGLFunc( cast( void** )&glMultiDrawArraysEXT, "glMultiDrawArraysEXT" );
        bindGLFunc( cast( void** )&glMultiDrawElementsEXT, "glMultiDrawElementsEXT" );

        _GL_EXT_multi_draw_arrays = true;
    } catch( Exception e ) {
        _GL_EXT_multi_draw_arrays = false;
    }
}

private __gshared bool _GL_EXT_multisampled_render_to_texture;
bool GL_EXT_multisampled_render_to_texture() @property { return _GL_EXT_multisampled_render_to_texture; }
enum : uint {
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = 0x8D6C,
    GL_RENDERBUFFER_SAMPLES_EXT       = 0x8CAB,
    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = 0x8D56,
    GL_MAX_SAMPLES_EXT                = 0x8D57,
}
extern( System ) nothrow {
    alias da_glRenderbufferStorageMultisampleEXT = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei );
    alias da_glFramebufferTexture2DMultisampleEXT = void function( GLenum, GLenum, GLenum, GLuint, GLint, GLsizei );
}
__gshared {
    da_glRenderbufferStorageMultisampleEXT glRenderbufferStorageMultisampleEXT;
    da_glFramebufferTexture2DMultisampleEXT glFramebufferTexture2DMultisampleEXT;
}
private void load_GL_EXT_multisampled_render_to_texture() {
    try {
        bindGLFunc( cast( void** )&glRenderbufferStorageMultisampleEXT, "glRenderbufferStorageMultisampleEXT" );
        bindGLFunc( cast( void** )&glFramebufferTexture2DMultisampleEXT, "glFramebufferTexture2DMultisampleEXT" );

        _GL_EXT_multisampled_render_to_texture = true;
    } catch( Exception e ) {
        _GL_EXT_multisampled_render_to_texture = false;
    }
}

private __gshared bool _GL_EXT_multiview_draw_buffers;
bool GL_EXT_multiview_draw_buffers() @property { return _GL_EXT_multiview_draw_buffers; }
enum : uint {
    GL_COLOR_ATTACHMENT_EXT           = 0x90F0,
    GL_MULTIVIEW_EXT                  = 0x90F1,
    GL_DRAW_BUFFER_EXT                = 0x0C01,
    GL_READ_BUFFER_EXT                = 0x0C02,
    GL_MAX_MULTIVIEW_BUFFERS_EXT      = 0x90F2,
}
extern( System ) nothrow {
    alias da_glReadBufferIndexedEXT = void function( GLenum, GLint );
    alias da_glDrawBuffersIndexedEXT = void function( GLint, const GLenum*, const GLint* );
    alias da_glGetIntegeri_vEXT = void function( GLenum, GLuint, GLint* );
}
__gshared {
    da_glReadBufferIndexedEXT glReadBufferIndexedEXT;
    da_glDrawBuffersIndexedEXT glDrawBuffersIndexedEXT;
    da_glGetIntegeri_vEXT glGetIntegeri_vEXT;
}
private void load_GL_EXT_multiview_draw_buffers() {
    try {
        bindGLFunc( cast( void** )&glReadBufferIndexedEXT, "glReadBufferIndexedEXT" );
        bindGLFunc( cast( void** )&glDrawBuffersIndexedEXT, "glDrawBuffersIndexedEXT" );
        bindGLFunc( cast( void** )&glGetIntegeri_vEXT, "glGetIntegeri_vEXT" );

        _GL_EXT_multiview_draw_buffers = true;
    } catch( Exception e ) {
        _GL_EXT_multiview_draw_buffers = false;
    }
}

private __gshared bool _GL_EXT_occlusion_query_boolean;
bool GL_EXT_occlusion_query_boolean() @property { return _GL_EXT_occlusion_query_boolean; }
enum : uint {
    GL_ANY_SAMPLES_PASSED_EXT         = 0x8C2F,
    GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = 0x8D6A,
}

private __gshared bool _GL_EXT_pvrtc_sRGB;
bool GL_EXT_pvrtc_sRGB() @property { return _GL_EXT_pvrtc_sRGB; }
enum : uint {
    GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = 0x8A54,
    GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = 0x8A55,
    GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = 0x8A56,
    GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = 0x8A57,
}

private __gshared bool _GL_EXT_read_format_bgra;
bool GL_EXT_read_format_bgra() @property { return _GL_EXT_read_format_bgra; }
enum : uint {
    GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT = 0x8365,
    GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT = 0x8366,
}

private __gshared bool _GL_EXT_robustness;
bool GL_EXT_robustness() @property { return _GL_EXT_robustness; }
enum : uint {
    GL_GUILTY_CONTEXT_RESET_EXT       = 0x8253,
    GL_INNOCENT_CONTEXT_RESET_EXT     = 0x8254,
    GL_UNKNOWN_CONTEXT_RESET_EXT      = 0x8255,
    GL_CONTEXT_ROBUST_ACCESS_EXT      = 0x90F3,
    GL_RESET_NOTIFICATION_STRATEGY_EXT = 0x8256,
    GL_LOSE_CONTEXT_ON_RESET_EXT      = 0x8252,
    GL_NO_RESET_NOTIFICATION_EXT      = 0x8261,
}
extern( System ) nothrow {
    alias da_glGetGraphicsResetStatusEXT = GLenum function(  );
    alias da_glReadnPixelsEXT = void function( GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, void* );
    alias da_glGetnUniformfvEXT = void function( GLuint, GLint, GLsizei, GLfloat* );
    alias da_glGetnUniformivEXT = void function( GLuint, GLint, GLsizei, GLint* );
}
__gshared {
    da_glGetGraphicsResetStatusEXT glGetGraphicsResetStatusEXT;
    da_glReadnPixelsEXT glReadnPixelsEXT;
    da_glGetnUniformfvEXT glGetnUniformfvEXT;
    da_glGetnUniformivEXT glGetnUniformivEXT;
}
private void load_GL_EXT_robustness() {
    try {
        bindGLFunc( cast( void** )&glGetGraphicsResetStatusEXT, "glGetGraphicsResetStatusEXT" );
        bindGLFunc( cast( void** )&glReadnPixelsEXT, "glReadnPixelsEXT" );
        bindGLFunc( cast( void** )&glGetnUniformfvEXT, "glGetnUniformfvEXT" );
        bindGLFunc( cast( void** )&glGetnUniformivEXT, "glGetnUniformivEXT" );

        _GL_EXT_robustness = true;
    } catch( Exception e ) {
        _GL_EXT_robustness = false;
    }
}

private __gshared bool _GL_EXT_sRGB;
bool GL_EXT_sRGB() @property { return _GL_EXT_sRGB; }
enum : uint {
    GL_SRGB_EXT                       = 0x8C40,
    GL_SRGB_ALPHA_EXT                 = 0x8C42,
    GL_SRGB8_ALPHA8_EXT               = 0x8C43,
    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x8210,
}

private __gshared bool _GL_EXT_sRGB_write_control;
bool GL_EXT_sRGB_write_control() @property { return _GL_EXT_sRGB_write_control; }
enum : uint {
    GL_FRAMEBUFFER_SRGB_EXT           = 0x8DB9,
}

private __gshared bool _GL_EXT_separate_shader_objects;
bool GL_EXT_separate_shader_objects() @property { return _GL_EXT_separate_shader_objects; }
enum : uint {
    GL_ACTIVE_PROGRAM_EXT             = 0x8259,
    GL_VERTEX_SHADER_BIT_EXT          = 0x00000001,
    GL_FRAGMENT_SHADER_BIT_EXT        = 0x00000002,
    GL_ALL_SHADER_BITS_EXT            = 0xFFFFFFFF,
    GL_PROGRAM_SEPARABLE_EXT          = 0x8258,
    GL_PROGRAM_PIPELINE_BINDING_EXT   = 0x825A,
}
extern( System ) nothrow {
    alias da_glActiveShaderProgramEXT = void function( GLuint, GLuint );
    alias da_glBindProgramPipelineEXT = void function( GLuint );
    alias da_glCreateShaderProgramvEXT = GLuint function( GLenum, GLsizei, const GLchar** );
    alias da_glDeleteProgramPipelinesEXT = void function( GLsizei, const GLuint* );
    alias da_glGenProgramPipelinesEXT = void function( GLsizei, GLuint* );
    alias da_glGetProgramPipelineInfoLogEXT = void function( GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glGetProgramPipelineivEXT = void function( GLuint, GLenum, GLint* );
    alias da_glIsProgramPipelineEXT = GLboolean function( GLuint );
    alias da_glProgramParameteriEXT = void function( GLuint, GLenum, GLint );
    alias da_glProgramUniform1fEXT = void function( GLuint, GLint, GLfloat );
    alias da_glProgramUniform1fvEXT = void function( GLuint, GLint, GLsizei, const GLfloat* );
    alias da_glProgramUniform1iEXT = void function( GLuint, GLint, GLint );
    alias da_glProgramUniform1ivEXT = void function( GLuint, GLint, GLsizei, const GLint* );
    alias da_glProgramUniform2fEXT = void function( GLuint, GLint, GLfloat, GLfloat );
    alias da_glProgramUniform2fvEXT = void function( GLuint, GLint, GLsizei, const GLfloat* );
    alias da_glProgramUniform2iEXT = void function( GLuint, GLint, GLint, GLint );
    alias da_glProgramUniform2ivEXT = void function( GLuint, GLint, GLsizei, const GLint* );
    alias da_glProgramUniform3fEXT = void function( GLuint, GLint, GLfloat, GLfloat, GLfloat );
    alias da_glProgramUniform3fvEXT = void function( GLuint, GLint, GLsizei, const GLfloat* );
    alias da_glProgramUniform3iEXT = void function( GLuint, GLint, GLint, GLint, GLint );
    alias da_glProgramUniform3ivEXT = void function( GLuint, GLint, GLsizei, const GLint* );
    alias da_glProgramUniform4fEXT = void function( GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat );
    alias da_glProgramUniform4fvEXT = void function( GLuint, GLint, GLsizei, const GLfloat* );
    alias da_glProgramUniform4iEXT = void function( GLuint, GLint, GLint, GLint, GLint, GLint );
    alias da_glProgramUniform4ivEXT = void function( GLuint, GLint, GLsizei, const GLint* );
    alias da_glProgramUniformMatrix2fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glProgramUniformMatrix3fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glProgramUniformMatrix4fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glUseProgramStagesEXT = void function( GLuint, GLbitfield, GLuint );
    alias da_glValidateProgramPipelineEXT = void function( GLuint );
    alias da_glProgramUniform1uiEXT = void function( GLuint, GLint, GLuint );
    alias da_glProgramUniform2uiEXT = void function( GLuint, GLint, GLuint, GLuint );
    alias da_glProgramUniform3uiEXT = void function( GLuint, GLint, GLuint, GLuint, GLuint );
    alias da_glProgramUniform4uiEXT = void function( GLuint, GLint, GLuint, GLuint, GLuint, GLuint );
    alias da_glProgramUniform1uivEXT = void function( GLuint, GLint, GLsizei, const GLuint* );
    alias da_glProgramUniform2uivEXT = void function( GLuint, GLint, GLsizei, const GLuint* );
    alias da_glProgramUniform3uivEXT = void function( GLuint, GLint, GLsizei, const GLuint* );
    alias da_glProgramUniform4uivEXT = void function( GLuint, GLint, GLsizei, const GLuint* );
    alias da_glProgramUniformMatrix2x3fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glProgramUniformMatrix3x2fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glProgramUniformMatrix2x4fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glProgramUniformMatrix4x2fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glProgramUniformMatrix3x4fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glProgramUniformMatrix4x3fvEXT = void function( GLuint, GLint, GLsizei, GLboolean, const GLfloat* );
}
__gshared {
    da_glActiveShaderProgramEXT glActiveShaderProgramEXT;
    da_glBindProgramPipelineEXT glBindProgramPipelineEXT;
    da_glCreateShaderProgramvEXT glCreateShaderProgramvEXT;
    da_glDeleteProgramPipelinesEXT glDeleteProgramPipelinesEXT;
    da_glGenProgramPipelinesEXT glGenProgramPipelinesEXT;
    da_glGetProgramPipelineInfoLogEXT glGetProgramPipelineInfoLogEXT;
    da_glGetProgramPipelineivEXT glGetProgramPipelineivEXT;
    da_glIsProgramPipelineEXT glIsProgramPipelineEXT;
    da_glProgramParameteriEXT glProgramParameteriEXT;
    da_glProgramUniform1fEXT glProgramUniform1fEXT;
    da_glProgramUniform1fvEXT glProgramUniform1fvEXT;
    da_glProgramUniform1iEXT glProgramUniform1iEXT;
    da_glProgramUniform1ivEXT glProgramUniform1ivEXT;
    da_glProgramUniform2fEXT glProgramUniform2fEXT;
    da_glProgramUniform2fvEXT glProgramUniform2fvEXT;
    da_glProgramUniform2iEXT glProgramUniform2iEXT;
    da_glProgramUniform2ivEXT glProgramUniform2ivEXT;
    da_glProgramUniform3fEXT glProgramUniform3fEXT;
    da_glProgramUniform3fvEXT glProgramUniform3fvEXT;
    da_glProgramUniform3iEXT glProgramUniform3iEXT;
    da_glProgramUniform3ivEXT glProgramUniform3ivEXT;
    da_glProgramUniform4fEXT glProgramUniform4fEXT;
    da_glProgramUniform4fvEXT glProgramUniform4fvEXT;
    da_glProgramUniform4iEXT glProgramUniform4iEXT;
    da_glProgramUniform4ivEXT glProgramUniform4ivEXT;
    da_glProgramUniformMatrix2fvEXT glProgramUniformMatrix2fvEXT;
    da_glProgramUniformMatrix3fvEXT glProgramUniformMatrix3fvEXT;
    da_glProgramUniformMatrix4fvEXT glProgramUniformMatrix4fvEXT;
    da_glUseProgramStagesEXT glUseProgramStagesEXT;
    da_glValidateProgramPipelineEXT glValidateProgramPipelineEXT;
    da_glProgramUniform1uiEXT glProgramUniform1uiEXT;
    da_glProgramUniform2uiEXT glProgramUniform2uiEXT;
    da_glProgramUniform3uiEXT glProgramUniform3uiEXT;
    da_glProgramUniform4uiEXT glProgramUniform4uiEXT;
    da_glProgramUniform1uivEXT glProgramUniform1uivEXT;
    da_glProgramUniform2uivEXT glProgramUniform2uivEXT;
    da_glProgramUniform3uivEXT glProgramUniform3uivEXT;
    da_glProgramUniform4uivEXT glProgramUniform4uivEXT;
    da_glProgramUniformMatrix2x3fvEXT glProgramUniformMatrix2x3fvEXT;
    da_glProgramUniformMatrix3x2fvEXT glProgramUniformMatrix3x2fvEXT;
    da_glProgramUniformMatrix2x4fvEXT glProgramUniformMatrix2x4fvEXT;
    da_glProgramUniformMatrix4x2fvEXT glProgramUniformMatrix4x2fvEXT;
    da_glProgramUniformMatrix3x4fvEXT glProgramUniformMatrix3x4fvEXT;
    da_glProgramUniformMatrix4x3fvEXT glProgramUniformMatrix4x3fvEXT;
}
private void load_GL_EXT_separate_shader_objects() {
    try {
        bindGLFunc( cast( void** )&glActiveShaderProgramEXT, "glActiveShaderProgramEXT" );
        bindGLFunc( cast( void** )&glBindProgramPipelineEXT, "glBindProgramPipelineEXT" );
        bindGLFunc( cast( void** )&glCreateShaderProgramvEXT, "glCreateShaderProgramvEXT" );
        bindGLFunc( cast( void** )&glDeleteProgramPipelinesEXT, "glDeleteProgramPipelinesEXT" );
        bindGLFunc( cast( void** )&glGenProgramPipelinesEXT, "glGenProgramPipelinesEXT" );
        bindGLFunc( cast( void** )&glGetProgramPipelineInfoLogEXT, "glGetProgramPipelineInfoLogEXT" );
        bindGLFunc( cast( void** )&glGetProgramPipelineivEXT, "glGetProgramPipelineivEXT" );
        bindGLFunc( cast( void** )&glIsProgramPipelineEXT, "glIsProgramPipelineEXT" );
        bindGLFunc( cast( void** )&glProgramParameteriEXT, "glProgramParameteriEXT" );
        bindGLFunc( cast( void** )&glProgramUniform1fEXT, "glProgramUniform1fEXT" );
        bindGLFunc( cast( void** )&glProgramUniform1fvEXT, "glProgramUniform1fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniform1iEXT, "glProgramUniform1iEXT" );
        bindGLFunc( cast( void** )&glProgramUniform1ivEXT, "glProgramUniform1ivEXT" );
        bindGLFunc( cast( void** )&glProgramUniform2fEXT, "glProgramUniform2fEXT" );
        bindGLFunc( cast( void** )&glProgramUniform2fvEXT, "glProgramUniform2fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniform2iEXT, "glProgramUniform2iEXT" );
        bindGLFunc( cast( void** )&glProgramUniform2ivEXT, "glProgramUniform2ivEXT" );
        bindGLFunc( cast( void** )&glProgramUniform3fEXT, "glProgramUniform3fEXT" );
        bindGLFunc( cast( void** )&glProgramUniform3fvEXT, "glProgramUniform3fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniform3iEXT, "glProgramUniform3iEXT" );
        bindGLFunc( cast( void** )&glProgramUniform3ivEXT, "glProgramUniform3ivEXT" );
        bindGLFunc( cast( void** )&glProgramUniform4fEXT, "glProgramUniform4fEXT" );
        bindGLFunc( cast( void** )&glProgramUniform4fvEXT, "glProgramUniform4fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniform4iEXT, "glProgramUniform4iEXT" );
        bindGLFunc( cast( void** )&glProgramUniform4ivEXT, "glProgramUniform4ivEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2fvEXT, "glProgramUniformMatrix2fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3fvEXT, "glProgramUniformMatrix3fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4fvEXT, "glProgramUniformMatrix4fvEXT" );
        bindGLFunc( cast( void** )&glUseProgramStagesEXT, "glUseProgramStagesEXT" );
        bindGLFunc( cast( void** )&glValidateProgramPipelineEXT, "glValidateProgramPipelineEXT" );
        bindGLFunc( cast( void** )&glProgramUniform1uiEXT, "glProgramUniform1uiEXT" );
        bindGLFunc( cast( void** )&glProgramUniform2uiEXT, "glProgramUniform2uiEXT" );
        bindGLFunc( cast( void** )&glProgramUniform3uiEXT, "glProgramUniform3uiEXT" );
        bindGLFunc( cast( void** )&glProgramUniform4uiEXT, "glProgramUniform4uiEXT" );
        bindGLFunc( cast( void** )&glProgramUniform1uivEXT, "glProgramUniform1uivEXT" );
        bindGLFunc( cast( void** )&glProgramUniform2uivEXT, "glProgramUniform2uivEXT" );
        bindGLFunc( cast( void** )&glProgramUniform3uivEXT, "glProgramUniform3uivEXT" );
        bindGLFunc( cast( void** )&glProgramUniform4uivEXT, "glProgramUniform4uivEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2x3fvEXT, "glProgramUniformMatrix2x3fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3x2fvEXT, "glProgramUniformMatrix3x2fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix2x4fvEXT, "glProgramUniformMatrix2x4fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4x2fvEXT, "glProgramUniformMatrix4x2fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix3x4fvEXT, "glProgramUniformMatrix3x4fvEXT" );
        bindGLFunc( cast( void** )&glProgramUniformMatrix4x3fvEXT, "glProgramUniformMatrix4x3fvEXT" );

        _GL_EXT_separate_shader_objects = true;
    } catch( Exception e ) {
        _GL_EXT_separate_shader_objects = false;
    }
}

private __gshared bool _GL_EXT_shader_framebuffer_fetch;
bool GL_EXT_shader_framebuffer_fetch() @property { return _GL_EXT_shader_framebuffer_fetch; }
enum : uint {
    GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = 0x8A52,
}

private __gshared bool _GL_EXT_shader_integer_mix;
bool GL_EXT_shader_integer_mix() @property { return _GL_EXT_shader_integer_mix; }

private __gshared bool _GL_EXT_shader_pixel_local_storage;
bool GL_EXT_shader_pixel_local_storage() @property { return _GL_EXT_shader_pixel_local_storage; }
enum : uint {
    GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = 0x8F63,
    GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = 0x8F67,
    GL_SHADER_PIXEL_LOCAL_STORAGE_EXT = 0x8F64,
}

private __gshared bool _GL_EXT_shader_texture_lod;
bool GL_EXT_shader_texture_lod() @property { return _GL_EXT_shader_texture_lod; }

private __gshared bool _GL_EXT_shadow_samplers;
bool GL_EXT_shadow_samplers() @property { return _GL_EXT_shadow_samplers; }
enum : uint {
    GL_TEXTURE_COMPARE_MODE_EXT       = 0x884C,
    GL_TEXTURE_COMPARE_FUNC_EXT       = 0x884D,
    GL_COMPARE_REF_TO_TEXTURE_EXT     = 0x884E,
    GL_SAMPLER_2D_SHADOW_EXT          = 0x8B62,
}

private __gshared bool _GL_EXT_texture_compression_dxt1;
bool GL_EXT_texture_compression_dxt1() @property { return _GL_EXT_texture_compression_dxt1; }
enum : uint {
    GL_COMPRESSED_RGB_S3TC_DXT1_EXT   = 0x83F0,
    GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  = 0x83F1,
}

private __gshared bool _GL_EXT_texture_compression_s3tc;
bool GL_EXT_texture_compression_s3tc() @property { return _GL_EXT_texture_compression_s3tc; }
enum : uint {
    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  = 0x83F2,
    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  = 0x83F3,
}

private __gshared bool _GL_EXT_texture_filter_anisotropic;
bool GL_EXT_texture_filter_anisotropic() @property { return _GL_EXT_texture_filter_anisotropic; }
enum : uint {
    GL_TEXTURE_MAX_ANISOTROPY_EXT     = 0x84FE,
    GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF,
}

private __gshared bool _GL_EXT_texture_format_BGRA8888;
bool GL_EXT_texture_format_BGRA8888() @property { return _GL_EXT_texture_format_BGRA8888; }

private __gshared bool _GL_EXT_texture_rg;
bool GL_EXT_texture_rg() @property { return _GL_EXT_texture_rg; }
enum : uint {
    GL_RED_EXT                        = 0x1903,
    GL_RG_EXT                         = 0x8227,
    GL_R8_EXT                         = 0x8229,
    GL_RG8_EXT                        = 0x822B,
}

private __gshared bool _GL_EXT_texture_sRGB_decode;
bool GL_EXT_texture_sRGB_decode() @property { return _GL_EXT_texture_sRGB_decode; }
enum : uint {
    GL_TEXTURE_SRGB_DECODE_EXT        = 0x8A48,
    GL_DECODE_EXT                     = 0x8A49,
    GL_SKIP_DECODE_EXT                = 0x8A4A,
}

private __gshared bool _GL_EXT_texture_storage;
bool GL_EXT_texture_storage() @property { return _GL_EXT_texture_storage; }
enum : uint {
    GL_TEXTURE_IMMUTABLE_FORMAT_EXT   = 0x912F,
    GL_ALPHA8_EXT                     = 0x803C,
    GL_LUMINANCE8_EXT                 = 0x8040,
    GL_LUMINANCE8_ALPHA8_EXT          = 0x8045,
    GL_RGBA32F_EXT                    = 0x8814,
    GL_RGB32F_EXT                     = 0x8815,
    GL_ALPHA32F_EXT                   = 0x8816,
    GL_LUMINANCE32F_EXT               = 0x8818,
    GL_LUMINANCE_ALPHA32F_EXT         = 0x8819,
    GL_ALPHA16F_EXT                   = 0x881C,
    GL_LUMINANCE16F_EXT               = 0x881E,
    GL_LUMINANCE_ALPHA16F_EXT         = 0x881F,
    GL_R32F_EXT                       = 0x822E,
    GL_RG32F_EXT                      = 0x8230,
}
extern( System ) nothrow {
    alias da_glTexStorage1DEXT = void function( GLenum, GLsizei, GLenum, GLsizei );
    alias da_glTexStorage2DEXT = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei );
    alias da_glTexStorage3DEXT = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei );
    alias da_glTextureStorage1DEXT = void function( GLuint, GLenum, GLsizei, GLenum, GLsizei );
    alias da_glTextureStorage2DEXT = void function( GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei );
    alias da_glTextureStorage3DEXT = void function( GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei );
}
__gshared {
    da_glTexStorage1DEXT glTexStorage1DEXT;
    da_glTexStorage2DEXT glTexStorage2DEXT;
    da_glTexStorage3DEXT glTexStorage3DEXT;
    da_glTextureStorage1DEXT glTextureStorage1DEXT;
    da_glTextureStorage2DEXT glTextureStorage2DEXT;
    da_glTextureStorage3DEXT glTextureStorage3DEXT;
}
private void load_GL_EXT_texture_storage() {
    try {
        bindGLFunc( cast( void** )&glTexStorage1DEXT, "glTexStorage1DEXT" );
        bindGLFunc( cast( void** )&glTexStorage2DEXT, "glTexStorage2DEXT" );
        bindGLFunc( cast( void** )&glTexStorage3DEXT, "glTexStorage3DEXT" );
        bindGLFunc( cast( void** )&glTextureStorage1DEXT, "glTextureStorage1DEXT" );
        bindGLFunc( cast( void** )&glTextureStorage2DEXT, "glTextureStorage2DEXT" );
        bindGLFunc( cast( void** )&glTextureStorage3DEXT, "glTextureStorage3DEXT" );

        _GL_EXT_texture_storage = true;
    } catch( Exception e ) {
        _GL_EXT_texture_storage = false;
    }
}

private __gshared bool _GL_EXT_texture_type_2_10_10_10_REV;
bool GL_EXT_texture_type_2_10_10_10_REV() @property { return _GL_EXT_texture_type_2_10_10_10_REV; }
enum : uint {
    GL_UNSIGNED_INT_2_10_10_10_REV_EXT = 0x8368,
}

private __gshared bool _GL_EXT_unpack_subimage;
bool GL_EXT_unpack_subimage() @property { return _GL_EXT_unpack_subimage; }
enum : uint {
    GL_UNPACK_ROW_LENGTH_EXT          = 0x0CF2,
    GL_UNPACK_SKIP_ROWS_EXT           = 0x0CF3,
    GL_UNPACK_SKIP_PIXELS_EXT         = 0x0CF4,
}

private __gshared bool _GL_FJ_shader_binary_GCCSO;
bool GL_FJ_shader_binary_GCCSO() @property { return _GL_FJ_shader_binary_GCCSO; }
enum : uint {
    GL_GCCSO_SHADER_BINARY_FJ         = 0x9260,
}

private __gshared bool _GL_IMG_multisampled_render_to_texture;
bool GL_IMG_multisampled_render_to_texture() @property { return _GL_IMG_multisampled_render_to_texture; }
enum : uint {
    GL_RENDERBUFFER_SAMPLES_IMG       = 0x9133,
    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = 0x9134,
    GL_MAX_SAMPLES_IMG                = 0x9135,
    GL_TEXTURE_SAMPLES_IMG            = 0x9136,
}
extern( System ) nothrow {
    alias da_glRenderbufferStorageMultisampleIMG = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei );
    alias da_glFramebufferTexture2DMultisampleIMG = void function( GLenum, GLenum, GLenum, GLuint, GLint, GLsizei );
}
__gshared {
    da_glRenderbufferStorageMultisampleIMG glRenderbufferStorageMultisampleIMG;
    da_glFramebufferTexture2DMultisampleIMG glFramebufferTexture2DMultisampleIMG;
}
private void load_GL_IMG_multisampled_render_to_texture() {
    try {
        bindGLFunc( cast( void** )&glRenderbufferStorageMultisampleIMG, "glRenderbufferStorageMultisampleIMG" );
        bindGLFunc( cast( void** )&glFramebufferTexture2DMultisampleIMG, "glFramebufferTexture2DMultisampleIMG" );

        _GL_IMG_multisampled_render_to_texture = true;
    } catch( Exception e ) {
        _GL_IMG_multisampled_render_to_texture = false;
    }
}

private __gshared bool _GL_IMG_program_binary;
bool GL_IMG_program_binary() @property { return _GL_IMG_program_binary; }
enum : uint {
    GL_SGX_PROGRAM_BINARY_IMG         = 0x9130,
}

private __gshared bool _GL_IMG_read_format;
bool GL_IMG_read_format() @property { return _GL_IMG_read_format; }
enum : uint {
    GL_BGRA_IMG                       = 0x80E1,
    GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG = 0x8365,
}

private __gshared bool _GL_IMG_shader_binary;
bool GL_IMG_shader_binary() @property { return _GL_IMG_shader_binary; }
enum : uint {
    GL_SGX_BINARY_IMG                 = 0x8C0A,
}

private __gshared bool _GL_IMG_texture_compression_pvrtc;
bool GL_IMG_texture_compression_pvrtc() @property { return _GL_IMG_texture_compression_pvrtc; }
enum : uint {
    GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00,
    GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01,
    GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02,
    GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03,
}

private __gshared bool _GL_IMG_texture_compression_pvrtc2;
bool GL_IMG_texture_compression_pvrtc2() @property { return _GL_IMG_texture_compression_pvrtc2; }
enum : uint {
    GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = 0x9137,
    GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = 0x9138,
}

private __gshared bool _GL_INTEL_performance_query;
bool GL_INTEL_performance_query() @property { return _GL_INTEL_performance_query; }
enum : uint {
    GL_PERFQUERY_SINGLE_CONTEXT_INTEL = 0x00000000,
    GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = 0x00000001,
    GL_PERFQUERY_WAIT_INTEL           = 0x83FB,
    GL_PERFQUERY_FLUSH_INTEL          = 0x83FA,
    GL_PERFQUERY_DONOT_FLUSH_INTEL    = 0x83F9,
    GL_PERFQUERY_COUNTER_EVENT_INTEL  = 0x94F0,
    GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = 0x94F1,
    GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = 0x94F2,
    GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = 0x94F3,
    GL_PERFQUERY_COUNTER_RAW_INTEL    = 0x94F4,
    GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = 0x94F5,
    GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = 0x94F8,
    GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = 0x94F9,
    GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = 0x94FA,
    GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = 0x94FB,
    GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = 0x94FC,
    GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = 0x94FD,
    GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = 0x94FE,
    GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = 0x94FF,
    GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = 0x9500,
}
extern( System ) nothrow {
    alias da_glBeginPerfQueryINTEL = void function( GLuint );
    alias da_glCreatePerfQueryINTEL = void function( GLuint, GLuint* );
    alias da_glDeletePerfQueryINTEL = void function( GLuint );
    alias da_glEndPerfQueryINTEL = void function( GLuint );
    alias da_glGetFirstPerfQueryIdINTEL = void function( GLuint* );
    alias da_glGetNextPerfQueryIdINTEL = void function( GLuint, GLuint* );
    alias da_glGetPerfCounterInfoINTEL = void function( GLuint, GLuint, GLuint, GLchar*, GLuint, GLchar*, GLuint*, GLuint*, GLuint*, GLuint*, GLuint64* );
    alias da_glGetPerfQueryDataINTEL = void function( GLuint, GLuint, GLsizei, GLvoid*, GLuint* );
    alias da_glGetPerfQueryIdByNameINTEL = void function( GLchar*, GLuint* );
    alias da_glGetPerfQueryInfoINTEL = void function( GLuint, GLuint, GLchar*, GLuint*, GLuint*, GLuint*, GLuint* );
}
__gshared {
    da_glBeginPerfQueryINTEL glBeginPerfQueryINTEL;
    da_glCreatePerfQueryINTEL glCreatePerfQueryINTEL;
    da_glDeletePerfQueryINTEL glDeletePerfQueryINTEL;
    da_glEndPerfQueryINTEL glEndPerfQueryINTEL;
    da_glGetFirstPerfQueryIdINTEL glGetFirstPerfQueryIdINTEL;
    da_glGetNextPerfQueryIdINTEL glGetNextPerfQueryIdINTEL;
    da_glGetPerfCounterInfoINTEL glGetPerfCounterInfoINTEL;
    da_glGetPerfQueryDataINTEL glGetPerfQueryDataINTEL;
    da_glGetPerfQueryIdByNameINTEL glGetPerfQueryIdByNameINTEL;
    da_glGetPerfQueryInfoINTEL glGetPerfQueryInfoINTEL;
}
private void load_GL_INTEL_performance_query() {
    try {
        bindGLFunc( cast( void** )&glBeginPerfQueryINTEL, "glBeginPerfQueryINTEL" );
        bindGLFunc( cast( void** )&glCreatePerfQueryINTEL, "glCreatePerfQueryINTEL" );
        bindGLFunc( cast( void** )&glDeletePerfQueryINTEL, "glDeletePerfQueryINTEL" );
        bindGLFunc( cast( void** )&glEndPerfQueryINTEL, "glEndPerfQueryINTEL" );
        bindGLFunc( cast( void** )&glGetFirstPerfQueryIdINTEL, "glGetFirstPerfQueryIdINTEL" );
        bindGLFunc( cast( void** )&glGetNextPerfQueryIdINTEL, "glGetNextPerfQueryIdINTEL" );
        bindGLFunc( cast( void** )&glGetPerfCounterInfoINTEL, "glGetPerfCounterInfoINTEL" );
        bindGLFunc( cast( void** )&glGetPerfQueryDataINTEL, "glGetPerfQueryDataINTEL" );
        bindGLFunc( cast( void** )&glGetPerfQueryIdByNameINTEL, "glGetPerfQueryIdByNameINTEL" );
        bindGLFunc( cast( void** )&glGetPerfQueryInfoINTEL, "glGetPerfQueryInfoINTEL" );

        _GL_INTEL_performance_query = true;
    } catch( Exception e ) {
        _GL_INTEL_performance_query = false;
    }
}

private __gshared bool _GL_NV_blend_equation_advanced;
bool GL_NV_blend_equation_advanced() @property { return _GL_NV_blend_equation_advanced; }
enum : uint {
    GL_BLEND_OVERLAP_NV               = 0x9281,
    GL_BLEND_PREMULTIPLIED_SRC_NV     = 0x9280,
    GL_BLUE_NV                        = 0x1905,
    GL_COLORBURN_NV                   = 0x929A,
    GL_COLORDODGE_NV                  = 0x9299,
    GL_CONJOINT_NV                    = 0x9284,
    GL_CONTRAST_NV                    = 0x92A1,
    GL_DARKEN_NV                      = 0x9297,
    GL_DIFFERENCE_NV                  = 0x929E,
    GL_DISJOINT_NV                    = 0x9283,
    GL_DST_ATOP_NV                    = 0x928F,
    GL_DST_IN_NV                      = 0x928B,
    GL_DST_NV                         = 0x9287,
    GL_DST_OUT_NV                     = 0x928D,
    GL_DST_OVER_NV                    = 0x9289,
    GL_EXCLUSION_NV                   = 0x92A0,
    GL_GREEN_NV                       = 0x1904,
    GL_HARDLIGHT_NV                   = 0x929B,
    GL_HARDMIX_NV                     = 0x92A9,
    GL_HSL_COLOR_NV                   = 0x92AF,
    GL_HSL_HUE_NV                     = 0x92AD,
    GL_HSL_LUMINOSITY_NV              = 0x92B0,
    GL_HSL_SATURATION_NV              = 0x92AE,
    GL_INVERT_OVG_NV                  = 0x92B4,
    GL_INVERT_RGB_NV                  = 0x92A3,
    GL_LIGHTEN_NV                     = 0x9298,
    GL_LINEARBURN_NV                  = 0x92A5,
    GL_LINEARDODGE_NV                 = 0x92A4,
    GL_LINEARLIGHT_NV                 = 0x92A7,
    GL_MINUS_CLAMPED_NV               = 0x92B3,
    GL_MINUS_NV                       = 0x929F,
    GL_MULTIPLY_NV                    = 0x9294,
    GL_OVERLAY_NV                     = 0x9296,
    GL_PINLIGHT_NV                    = 0x92A8,
    GL_PLUS_CLAMPED_ALPHA_NV          = 0x92B2,
    GL_PLUS_CLAMPED_NV                = 0x92B1,
    GL_PLUS_DARKER_NV                 = 0x9292,
    GL_PLUS_NV                        = 0x9291,
    GL_RED_NV                         = 0x1903,
    GL_SCREEN_NV                      = 0x9295,
    GL_SOFTLIGHT_NV                   = 0x929C,
    GL_SRC_ATOP_NV                    = 0x928E,
    GL_SRC_IN_NV                      = 0x928A,
    GL_SRC_NV                         = 0x9286,
    GL_SRC_OUT_NV                     = 0x928C,
    GL_SRC_OVER_NV                    = 0x9288,
    GL_UNCORRELATED_NV                = 0x9282,
    GL_VIVIDLIGHT_NV                  = 0x92A6,
    GL_XOR_NV                         = 0x1506,
}
extern( System ) nothrow {
    alias da_glBlendParameteriNV = void function( GLenum, GLint );
    alias da_glBlendBarrierNV = void function(  );
}
__gshared {
    da_glBlendParameteriNV glBlendParameteriNV;
    da_glBlendBarrierNV glBlendBarrierNV;
}
private void load_GL_NV_blend_equation_advanced() {
    try {
        bindGLFunc( cast( void** )&glBlendParameteriNV, "glBlendParameteriNV" );
        bindGLFunc( cast( void** )&glBlendBarrierNV, "glBlendBarrierNV" );

        _GL_NV_blend_equation_advanced = true;
    } catch( Exception e ) {
        _GL_NV_blend_equation_advanced = false;
    }
}

private __gshared bool _GL_NV_blend_equation_advanced_coherent;
bool GL_NV_blend_equation_advanced_coherent() @property { return _GL_NV_blend_equation_advanced_coherent; }
enum : uint {
    GL_BLEND_ADVANCED_COHERENT_NV     = 0x9285,
}

private __gshared bool _GL_NV_copy_buffer;
bool GL_NV_copy_buffer() @property { return _GL_NV_copy_buffer; }
enum : uint {
    GL_COPY_READ_BUFFER_NV            = 0x8F36,
    GL_COPY_WRITE_BUFFER_NV           = 0x8F37,
}
extern( System ) nothrow {
    alias da_glCopyBufferSubDataNV = void function( GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr );
}
__gshared {
    da_glCopyBufferSubDataNV glCopyBufferSubDataNV;
}
private void load_GL_NV_copy_buffer() {
    try {
        bindGLFunc( cast( void** )&glCopyBufferSubDataNV, "glCopyBufferSubDataNV" );

        _GL_NV_copy_buffer = true;
    } catch( Exception e ) {
        _GL_NV_copy_buffer = false;
    }
}

private __gshared bool _GL_NV_coverage_sample;
bool GL_NV_coverage_sample() @property { return _GL_NV_coverage_sample; }
enum : uint {
    GL_COVERAGE_COMPONENT_NV          = 0x8ED0,
    GL_COVERAGE_COMPONENT4_NV         = 0x8ED1,
    GL_COVERAGE_ATTACHMENT_NV         = 0x8ED2,
    GL_COVERAGE_BUFFERS_NV            = 0x8ED3,
    GL_COVERAGE_SAMPLES_NV            = 0x8ED4,
    GL_COVERAGE_ALL_FRAGMENTS_NV      = 0x8ED5,
    GL_COVERAGE_EDGE_FRAGMENTS_NV     = 0x8ED6,
    GL_COVERAGE_AUTOMATIC_NV          = 0x8ED7,
    GL_COVERAGE_BUFFER_BIT_NV         = 0x00008000,
}
extern( System ) nothrow {
    alias da_glCoverageMaskNV = void function( GLboolean );
    alias da_glCoverageOperationNV = void function( GLenum );
}
__gshared {
    da_glCoverageMaskNV glCoverageMaskNV;
    da_glCoverageOperationNV glCoverageOperationNV;
}
private void load_GL_NV_coverage_sample() {
    try {
        bindGLFunc( cast( void** )&glCoverageMaskNV, "glCoverageMaskNV" );
        bindGLFunc( cast( void** )&glCoverageOperationNV, "glCoverageOperationNV" );

        _GL_NV_coverage_sample = true;
    } catch( Exception e ) {
        _GL_NV_coverage_sample = false;
    }
}

private __gshared bool _GL_NV_depth_nonlinear;
bool GL_NV_depth_nonlinear() @property { return _GL_NV_depth_nonlinear; }
enum : uint {
    GL_DEPTH_COMPONENT16_NONLINEAR_NV = 0x8E2C,
}

private __gshared bool _GL_NV_draw_buffers;
bool GL_NV_draw_buffers() @property { return _GL_NV_draw_buffers; }
enum : uint {
    GL_MAX_DRAW_BUFFERS_NV            = 0x8824,
    GL_DRAW_BUFFER0_NV                = 0x8825,
    GL_DRAW_BUFFER1_NV                = 0x8826,
    GL_DRAW_BUFFER2_NV                = 0x8827,
    GL_DRAW_BUFFER3_NV                = 0x8828,
    GL_DRAW_BUFFER4_NV                = 0x8829,
    GL_DRAW_BUFFER5_NV                = 0x882A,
    GL_DRAW_BUFFER6_NV                = 0x882B,
    GL_DRAW_BUFFER7_NV                = 0x882C,
    GL_DRAW_BUFFER8_NV                = 0x882D,
    GL_DRAW_BUFFER9_NV                = 0x882E,
    GL_DRAW_BUFFER10_NV               = 0x882F,
    GL_DRAW_BUFFER11_NV               = 0x8830,
    GL_DRAW_BUFFER12_NV               = 0x8831,
    GL_DRAW_BUFFER13_NV               = 0x8832,
    GL_DRAW_BUFFER14_NV               = 0x8833,
    GL_DRAW_BUFFER15_NV               = 0x8834,
    GL_COLOR_ATTACHMENT0_NV           = 0x8CE0,
    GL_COLOR_ATTACHMENT1_NV           = 0x8CE1,
    GL_COLOR_ATTACHMENT2_NV           = 0x8CE2,
    GL_COLOR_ATTACHMENT3_NV           = 0x8CE3,
    GL_COLOR_ATTACHMENT4_NV           = 0x8CE4,
    GL_COLOR_ATTACHMENT5_NV           = 0x8CE5,
    GL_COLOR_ATTACHMENT6_NV           = 0x8CE6,
    GL_COLOR_ATTACHMENT7_NV           = 0x8CE7,
    GL_COLOR_ATTACHMENT8_NV           = 0x8CE8,
    GL_COLOR_ATTACHMENT9_NV           = 0x8CE9,
    GL_COLOR_ATTACHMENT10_NV          = 0x8CEA,
    GL_COLOR_ATTACHMENT11_NV          = 0x8CEB,
    GL_COLOR_ATTACHMENT12_NV          = 0x8CEC,
    GL_COLOR_ATTACHMENT13_NV          = 0x8CED,
    GL_COLOR_ATTACHMENT14_NV          = 0x8CEE,
    GL_COLOR_ATTACHMENT15_NV          = 0x8CEF,
}
extern( System ) nothrow {
    alias da_glDrawBuffersNV = void function( GLsizei, const GLenum* );
}
__gshared {
    da_glDrawBuffersNV glDrawBuffersNV;
}
private void load_GL_NV_draw_buffers() {
    try {
        bindGLFunc( cast( void** )&glDrawBuffersNV, "glDrawBuffersNV" );

        _GL_NV_draw_buffers = true;
    } catch( Exception e ) {
        _GL_NV_draw_buffers = false;
    }
}

private __gshared bool _GL_NV_draw_instanced;
bool GL_NV_draw_instanced() @property { return _GL_NV_draw_instanced; }
extern( System ) nothrow {
    alias da_glDrawArraysInstancedNV = void function( GLenum, GLint, GLsizei, GLsizei );
    alias da_glDrawElementsInstancedNV = void function( GLenum, GLsizei, GLenum, const void*, GLsizei );
}
__gshared {
    da_glDrawArraysInstancedNV glDrawArraysInstancedNV;
    da_glDrawElementsInstancedNV glDrawElementsInstancedNV;
}
private void load_GL_NV_draw_instanced() {
    try {
        bindGLFunc( cast( void** )&glDrawArraysInstancedNV, "glDrawArraysInstancedNV" );
        bindGLFunc( cast( void** )&glDrawElementsInstancedNV, "glDrawElementsInstancedNV" );

        _GL_NV_draw_instanced = true;
    } catch( Exception e ) {
        _GL_NV_draw_instanced = false;
    }
}

private __gshared bool _GL_NV_explicit_attrib_location;
bool GL_NV_explicit_attrib_location() @property { return _GL_NV_explicit_attrib_location; }

private __gshared bool _GL_NV_fbo_color_attachments;
bool GL_NV_fbo_color_attachments() @property { return _GL_NV_fbo_color_attachments; }
enum : uint {
    GL_MAX_COLOR_ATTACHMENTS_NV       = 0x8CDF,
}

private __gshared bool _GL_NV_fence;
bool GL_NV_fence() @property { return _GL_NV_fence; }
enum : uint {
    GL_ALL_COMPLETED_NV               = 0x84F2,
    GL_FENCE_STATUS_NV                = 0x84F3,
    GL_FENCE_CONDITION_NV             = 0x84F4,
}
extern( System ) nothrow {
    alias da_glDeleteFencesNV = void function( GLsizei, const GLuint* );
    alias da_glGenFencesNV = void function( GLsizei, GLuint* );
    alias da_glIsFenceNV = GLboolean function( GLuint );
    alias da_glTestFenceNV = GLboolean function( GLuint );
    alias da_glGetFenceivNV = void function( GLuint, GLenum, GLint* );
    alias da_glFinishFenceNV = void function( GLuint );
    alias da_glSetFenceNV = void function( GLuint, GLenum );
}
__gshared {
    da_glDeleteFencesNV glDeleteFencesNV;
    da_glGenFencesNV glGenFencesNV;
    da_glIsFenceNV glIsFenceNV;
    da_glTestFenceNV glTestFenceNV;
    da_glGetFenceivNV glGetFenceivNV;
    da_glFinishFenceNV glFinishFenceNV;
    da_glSetFenceNV glSetFenceNV;
}
private void load_GL_NV_fence() {
    try {
        bindGLFunc( cast( void** )&glDeleteFencesNV, "glDeleteFencesNV" );
        bindGLFunc( cast( void** )&glGenFencesNV, "glGenFencesNV" );
        bindGLFunc( cast( void** )&glIsFenceNV, "glIsFenceNV" );
        bindGLFunc( cast( void** )&glTestFenceNV, "glTestFenceNV" );
        bindGLFunc( cast( void** )&glGetFenceivNV, "glGetFenceivNV" );
        bindGLFunc( cast( void** )&glFinishFenceNV, "glFinishFenceNV" );
        bindGLFunc( cast( void** )&glSetFenceNV, "glSetFenceNV" );

        _GL_NV_fence = true;
    } catch( Exception e ) {
        _GL_NV_fence = false;
    }
}

private __gshared bool _GL_NV_framebuffer_blit;
bool GL_NV_framebuffer_blit() @property { return _GL_NV_framebuffer_blit; }
enum : uint {
    GL_READ_FRAMEBUFFER_NV            = 0x8CA8,
    GL_DRAW_FRAMEBUFFER_NV            = 0x8CA9,
    GL_DRAW_FRAMEBUFFER_BINDING_NV    = 0x8CA6,
    GL_READ_FRAMEBUFFER_BINDING_NV    = 0x8CAA,
}
extern( System ) nothrow {
    alias da_glBlitFramebufferNV = void function( GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum );
}
__gshared {
    da_glBlitFramebufferNV glBlitFramebufferNV;
}
private void load_GL_NV_framebuffer_blit() {
    try {
        bindGLFunc( cast( void** )&glBlitFramebufferNV, "glBlitFramebufferNV" );

        _GL_NV_framebuffer_blit = true;
    } catch( Exception e ) {
        _GL_NV_framebuffer_blit = false;
    }
}

private __gshared bool _GL_NV_framebuffer_multisample;
bool GL_NV_framebuffer_multisample() @property { return _GL_NV_framebuffer_multisample; }
enum : uint {
    GL_RENDERBUFFER_SAMPLES_NV        = 0x8CAB,
    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = 0x8D56,
    GL_MAX_SAMPLES_NV                 = 0x8D57,
}
extern( System ) nothrow {
    alias da_glRenderbufferStorageMultisampleNV = void function( GLenum, GLsizei, GLenum, GLsizei, GLsizei );
}
__gshared {
    da_glRenderbufferStorageMultisampleNV glRenderbufferStorageMultisampleNV;
}
private void load_GL_NV_framebuffer_multisample() {
    try {
        bindGLFunc( cast( void** )&glRenderbufferStorageMultisampleNV, "glRenderbufferStorageMultisampleNV" );

        _GL_NV_framebuffer_multisample = true;
    } catch( Exception e ) {
        _GL_NV_framebuffer_multisample = false;
    }
}

private __gshared bool _GL_NV_generate_mipmap_sRGB;
bool GL_NV_generate_mipmap_sRGB() @property { return _GL_NV_generate_mipmap_sRGB; }

private __gshared bool _GL_NV_instanced_arrays;
bool GL_NV_instanced_arrays() @property { return _GL_NV_instanced_arrays; }
enum : uint {
    GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV = 0x88FE,
}
extern( System ) nothrow {
    alias da_glVertexAttribDivisorNV = void function( GLuint, GLuint );
}
__gshared {
    da_glVertexAttribDivisorNV glVertexAttribDivisorNV;
}
private void load_GL_NV_instanced_arrays() {
    try {
        bindGLFunc( cast( void** )&glVertexAttribDivisorNV, "glVertexAttribDivisorNV" );

        _GL_NV_instanced_arrays = true;
    } catch( Exception e ) {
        _GL_NV_instanced_arrays = false;
    }
}

private __gshared bool _GL_NV_non_square_matrices;
bool GL_NV_non_square_matrices() @property { return _GL_NV_non_square_matrices; }
enum : uint {
    GL_FLOAT_MAT2x3_NV                = 0x8B65,
    GL_FLOAT_MAT2x4_NV                = 0x8B66,
    GL_FLOAT_MAT3x2_NV                = 0x8B67,
    GL_FLOAT_MAT3x4_NV                = 0x8B68,
    GL_FLOAT_MAT4x2_NV                = 0x8B69,
    GL_FLOAT_MAT4x3_NV                = 0x8B6A,
}
extern( System ) nothrow {
    alias da_glUniformMatrix2x3fvNV = void function( GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glUniformMatrix3x2fvNV = void function( GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glUniformMatrix2x4fvNV = void function( GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glUniformMatrix4x2fvNV = void function( GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glUniformMatrix3x4fvNV = void function( GLint, GLsizei, GLboolean, const GLfloat* );
    alias da_glUniformMatrix4x3fvNV = void function( GLint, GLsizei, GLboolean, const GLfloat* );
}
__gshared {
    da_glUniformMatrix2x3fvNV glUniformMatrix2x3fvNV;
    da_glUniformMatrix3x2fvNV glUniformMatrix3x2fvNV;
    da_glUniformMatrix2x4fvNV glUniformMatrix2x4fvNV;
    da_glUniformMatrix4x2fvNV glUniformMatrix4x2fvNV;
    da_glUniformMatrix3x4fvNV glUniformMatrix3x4fvNV;
    da_glUniformMatrix4x3fvNV glUniformMatrix4x3fvNV;
}
private void load_GL_NV_non_square_matrices() {
    try {
        bindGLFunc( cast( void** )&glUniformMatrix2x3fvNV, "glUniformMatrix2x3fvNV" );
        bindGLFunc( cast( void** )&glUniformMatrix3x2fvNV, "glUniformMatrix3x2fvNV" );
        bindGLFunc( cast( void** )&glUniformMatrix2x4fvNV, "glUniformMatrix2x4fvNV" );
        bindGLFunc( cast( void** )&glUniformMatrix4x2fvNV, "glUniformMatrix4x2fvNV" );
        bindGLFunc( cast( void** )&glUniformMatrix3x4fvNV, "glUniformMatrix3x4fvNV" );
        bindGLFunc( cast( void** )&glUniformMatrix4x3fvNV, "glUniformMatrix4x3fvNV" );

        _GL_NV_non_square_matrices = true;
    } catch( Exception e ) {
        _GL_NV_non_square_matrices = false;
    }
}

private __gshared bool _GL_NV_read_buffer;
bool GL_NV_read_buffer() @property { return _GL_NV_read_buffer; }
enum : uint {
    GL_READ_BUFFER_NV                 = 0x0C02,
}
extern( System ) nothrow {
void glReadBufferNV ( GLenum );
}

private __gshared bool _GL_NV_read_buffer_front;
bool GL_NV_read_buffer_front() @property { return _GL_NV_read_buffer_front; }

private __gshared bool _GL_NV_read_depth;
bool GL_NV_read_depth() @property { return _GL_NV_read_depth; }

private __gshared bool _GL_NV_read_depth_stencil;
bool GL_NV_read_depth_stencil() @property { return _GL_NV_read_depth_stencil; }

private __gshared bool _GL_NV_read_stencil;
bool GL_NV_read_stencil() @property { return _GL_NV_read_stencil; }

private __gshared bool _GL_NV_sRGB_formats;
bool GL_NV_sRGB_formats() @property { return _GL_NV_sRGB_formats; }
enum : uint {
    GL_SLUMINANCE_NV                  = 0x8C46,
    GL_SLUMINANCE_ALPHA_NV            = 0x8C44,
    GL_SRGB8_NV                       = 0x8C41,
    GL_SLUMINANCE8_NV                 = 0x8C47,
    GL_SLUMINANCE8_ALPHA8_NV          = 0x8C45,
    GL_COMPRESSED_SRGB_S3TC_DXT1_NV   = 0x8C4C,
    GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = 0x8C4D,
    GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = 0x8C4E,
    GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = 0x8C4F,
    GL_ETC1_SRGB8_NV                  = 0x88EE,
}

private __gshared bool _GL_NV_shadow_samplers_array;
bool GL_NV_shadow_samplers_array() @property { return _GL_NV_shadow_samplers_array; }
enum : uint {
    GL_SAMPLER_2D_ARRAY_SHADOW_NV     = 0x8DC4,
}

private __gshared bool _GL_NV_shadow_samplers_cube;
bool GL_NV_shadow_samplers_cube() @property { return _GL_NV_shadow_samplers_cube; }
enum : uint {
    GL_SAMPLER_CUBE_SHADOW_NV         = 0x8DC5,
}

private __gshared bool _GL_NV_texture_border_clamp;
bool GL_NV_texture_border_clamp() @property { return _GL_NV_texture_border_clamp; }
enum : uint {
    GL_TEXTURE_BORDER_COLOR_NV        = 0x1004,
    GL_CLAMP_TO_BORDER_NV             = 0x812D,
}

private __gshared bool _GL_NV_texture_compression_s3tc_update;
bool GL_NV_texture_compression_s3tc_update() @property { return _GL_NV_texture_compression_s3tc_update; }

private __gshared bool _GL_NV_texture_npot_2D_mipmap;
bool GL_NV_texture_npot_2D_mipmap() @property { return _GL_NV_texture_npot_2D_mipmap; }

private __gshared bool _GL_QCOM_alpha_test;
bool GL_QCOM_alpha_test() @property { return _GL_QCOM_alpha_test; }
enum : uint {
    GL_ALPHA_TEST_QCOM                = 0x0BC0,
    GL_ALPHA_TEST_FUNC_QCOM           = 0x0BC1,
    GL_ALPHA_TEST_REF_QCOM            = 0x0BC2,
}
extern( System ) nothrow {
    alias da_glAlphaFuncQCOM = void function( GLenum, GLclampf );
}
__gshared {
    da_glAlphaFuncQCOM glAlphaFuncQCOM;
}
private void load_GL_QCOM_alpha_test() {
    try {
        bindGLFunc( cast( void** )&glAlphaFuncQCOM, "glAlphaFuncQCOM" );

        _GL_QCOM_alpha_test = true;
    } catch( Exception e ) {
        _GL_QCOM_alpha_test = false;
    }
}

private __gshared bool _GL_QCOM_binning_control;
bool GL_QCOM_binning_control() @property { return _GL_QCOM_binning_control; }
enum : uint {
    GL_BINNING_CONTROL_HINT_QCOM      = 0x8FB0,
    GL_CPU_OPTIMIZED_QCOM             = 0x8FB1,
    GL_GPU_OPTIMIZED_QCOM             = 0x8FB2,
    GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = 0x8FB3,
}

private __gshared bool _GL_QCOM_driver_control;
bool GL_QCOM_driver_control() @property { return _GL_QCOM_driver_control; }
extern( System ) nothrow {
    alias da_glGetDriverControlsQCOM = void function( GLint*, GLsizei, GLuint* );
    alias da_glGetDriverControlStringQCOM = void function( GLuint, GLsizei, GLsizei*, GLchar* );
    alias da_glEnableDriverControlQCOM = void function( GLuint );
    alias da_glDisableDriverControlQCOM = void function( GLuint );
}
__gshared {
    da_glGetDriverControlsQCOM glGetDriverControlsQCOM;
    da_glGetDriverControlStringQCOM glGetDriverControlStringQCOM;
    da_glEnableDriverControlQCOM glEnableDriverControlQCOM;
    da_glDisableDriverControlQCOM glDisableDriverControlQCOM;
}
private void load_GL_QCOM_driver_control() {
    try {
        bindGLFunc( cast( void** )&glGetDriverControlsQCOM, "glGetDriverControlsQCOM" );
        bindGLFunc( cast( void** )&glGetDriverControlStringQCOM, "glGetDriverControlStringQCOM" );
        bindGLFunc( cast( void** )&glEnableDriverControlQCOM, "glEnableDriverControlQCOM" );
        bindGLFunc( cast( void** )&glDisableDriverControlQCOM, "glDisableDriverControlQCOM" );

        _GL_QCOM_driver_control = true;
    } catch( Exception e ) {
        _GL_QCOM_driver_control = false;
    }
}

private __gshared bool _GL_QCOM_extended_get;
bool GL_QCOM_extended_get() @property { return _GL_QCOM_extended_get; }
enum : uint {
    GL_TEXTURE_WIDTH_QCOM             = 0x8BD2,
    GL_TEXTURE_HEIGHT_QCOM            = 0x8BD3,
    GL_TEXTURE_DEPTH_QCOM             = 0x8BD4,
    GL_TEXTURE_INTERNAL_FORMAT_QCOM   = 0x8BD5,
    GL_TEXTURE_FORMAT_QCOM            = 0x8BD6,
    GL_TEXTURE_TYPE_QCOM              = 0x8BD7,
    GL_TEXTURE_IMAGE_VALID_QCOM       = 0x8BD8,
    GL_TEXTURE_NUM_LEVELS_QCOM        = 0x8BD9,
    GL_TEXTURE_TARGET_QCOM            = 0x8BDA,
    GL_TEXTURE_OBJECT_VALID_QCOM      = 0x8BDB,
    GL_STATE_RESTORE                  = 0x8BDC,
}
extern( System ) nothrow {
    alias da_glExtGetTexturesQCOM = void function( GLuint*, GLint, GLint* );
    alias da_glExtGetBuffersQCOM = void function( GLuint*, GLint, GLint* );
    alias da_glExtGetRenderbuffersQCOM = void function( GLuint*, GLint, GLint* );
    alias da_glExtGetFramebuffersQCOM = void function( GLuint*, GLint, GLint* );
    alias da_glExtGetTexLevelParameterivQCOM = void function( GLuint, GLenum, GLint, GLenum, GLint* );
    alias da_glExtTexObjectStateOverrideiQCOM = void function( GLenum, GLenum, GLint );
    alias da_glExtGetTexSubImageQCOM = void function( GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, void* );
    alias da_glExtGetBufferPointervQCOM = void function( GLenum, void** );
}
__gshared {
    da_glExtGetTexturesQCOM glExtGetTexturesQCOM;
    da_glExtGetBuffersQCOM glExtGetBuffersQCOM;
    da_glExtGetRenderbuffersQCOM glExtGetRenderbuffersQCOM;
    da_glExtGetFramebuffersQCOM glExtGetFramebuffersQCOM;
    da_glExtGetTexLevelParameterivQCOM glExtGetTexLevelParameterivQCOM;
    da_glExtTexObjectStateOverrideiQCOM glExtTexObjectStateOverrideiQCOM;
    da_glExtGetTexSubImageQCOM glExtGetTexSubImageQCOM;
    da_glExtGetBufferPointervQCOM glExtGetBufferPointervQCOM;
}
private void load_GL_QCOM_extended_get() {
    try {
        bindGLFunc( cast( void** )&glExtGetTexturesQCOM, "glExtGetTexturesQCOM" );
        bindGLFunc( cast( void** )&glExtGetBuffersQCOM, "glExtGetBuffersQCOM" );
        bindGLFunc( cast( void** )&glExtGetRenderbuffersQCOM, "glExtGetRenderbuffersQCOM" );
        bindGLFunc( cast( void** )&glExtGetFramebuffersQCOM, "glExtGetFramebuffersQCOM" );
        bindGLFunc( cast( void** )&glExtGetTexLevelParameterivQCOM, "glExtGetTexLevelParameterivQCOM" );
        bindGLFunc( cast( void** )&glExtTexObjectStateOverrideiQCOM, "glExtTexObjectStateOverrideiQCOM" );
        bindGLFunc( cast( void** )&glExtGetTexSubImageQCOM, "glExtGetTexSubImageQCOM" );
        bindGLFunc( cast( void** )&glExtGetBufferPointervQCOM, "glExtGetBufferPointervQCOM" );

        _GL_QCOM_extended_get = true;
    } catch( Exception e ) {
        _GL_QCOM_extended_get = false;
    }
}

private __gshared bool _GL_QCOM_extended_get2;
bool GL_QCOM_extended_get2() @property { return _GL_QCOM_extended_get2; }
extern( System ) nothrow {
    alias da_glExtGetShadersQCOM = void function( GLuint*, GLint, GLint );
    alias da_glExtGetProgramsQCOM = void function( GLuint*, GLint, GLint* );
    alias da_glExtIsProgramBinaryQCOM = GLboolean function( GLuint );
    alias da_glExtGetProgramBinarySourceQCOM = void function( GLuint, GLenum, GLchar*, GLint* );
}
__gshared {
    da_glExtGetShadersQCOM glExtGetShadersQCOM;
    da_glExtGetProgramsQCOM glExtGetProgramsQCOM;
    da_glExtIsProgramBinaryQCOM glExtIsProgramBinaryQCOM;
    da_glExtGetProgramBinarySourceQCOM glExtGetProgramBinarySourceQCOM;
}
private void load_GL_QCOM_extended_get2() {
    try {
        bindGLFunc( cast( void** )&glExtGetShadersQCOM, "glExtGetShadersQCOM" );
        bindGLFunc( cast( void** )&glExtGetProgramsQCOM, "glExtGetProgramsQCOM" );
        bindGLFunc( cast( void** )&glExtIsProgramBinaryQCOM, "glExtIsProgramBinaryQCOM" );
        bindGLFunc( cast( void** )&glExtGetProgramBinarySourceQCOM, "glExtGetProgramBinarySourceQCOM" );

        _GL_QCOM_extended_get2 = true;
    } catch( Exception e ) {
        _GL_QCOM_extended_get2 = false;
    }
}

private __gshared bool _GL_QCOM_perfmon_global_mode;
bool GL_QCOM_perfmon_global_mode() @property { return _GL_QCOM_perfmon_global_mode; }
enum : uint {
    GL_PERFMON_GLOBAL_MODE_QCOM       = 0x8FA0,
}

private __gshared bool _GL_QCOM_tiled_rendering;
bool GL_QCOM_tiled_rendering() @property { return _GL_QCOM_tiled_rendering; }
enum : uint {
    GL_COLOR_BUFFER_BIT0_QCOM         = 0x00000001,
    GL_COLOR_BUFFER_BIT1_QCOM         = 0x00000002,
    GL_COLOR_BUFFER_BIT2_QCOM         = 0x00000004,
    GL_COLOR_BUFFER_BIT3_QCOM         = 0x00000008,
    GL_COLOR_BUFFER_BIT4_QCOM         = 0x00000010,
    GL_COLOR_BUFFER_BIT5_QCOM         = 0x00000020,
    GL_COLOR_BUFFER_BIT6_QCOM         = 0x00000040,
    GL_COLOR_BUFFER_BIT7_QCOM         = 0x00000080,
    GL_DEPTH_BUFFER_BIT0_QCOM         = 0x00000100,
    GL_DEPTH_BUFFER_BIT1_QCOM         = 0x00000200,
    GL_DEPTH_BUFFER_BIT2_QCOM         = 0x00000400,
    GL_DEPTH_BUFFER_BIT3_QCOM         = 0x00000800,
    GL_DEPTH_BUFFER_BIT4_QCOM         = 0x00001000,
    GL_DEPTH_BUFFER_BIT5_QCOM         = 0x00002000,
    GL_DEPTH_BUFFER_BIT6_QCOM         = 0x00004000,
    GL_DEPTH_BUFFER_BIT7_QCOM         = 0x00008000,
    GL_STENCIL_BUFFER_BIT0_QCOM       = 0x00010000,
    GL_STENCIL_BUFFER_BIT1_QCOM       = 0x00020000,
    GL_STENCIL_BUFFER_BIT2_QCOM       = 0x00040000,
    GL_STENCIL_BUFFER_BIT3_QCOM       = 0x00080000,
    GL_STENCIL_BUFFER_BIT4_QCOM       = 0x00100000,
    GL_STENCIL_BUFFER_BIT5_QCOM       = 0x00200000,
    GL_STENCIL_BUFFER_BIT6_QCOM       = 0x00400000,
    GL_STENCIL_BUFFER_BIT7_QCOM       = 0x00800000,
    GL_MULTISAMPLE_BUFFER_BIT0_QCOM   = 0x01000000,
    GL_MULTISAMPLE_BUFFER_BIT1_QCOM   = 0x02000000,
    GL_MULTISAMPLE_BUFFER_BIT2_QCOM   = 0x04000000,
    GL_MULTISAMPLE_BUFFER_BIT3_QCOM   = 0x08000000,
    GL_MULTISAMPLE_BUFFER_BIT4_QCOM   = 0x10000000,
    GL_MULTISAMPLE_BUFFER_BIT5_QCOM   = 0x20000000,
    GL_MULTISAMPLE_BUFFER_BIT6_QCOM   = 0x40000000,
    GL_MULTISAMPLE_BUFFER_BIT7_QCOM   = 0x80000000,
}
extern( System ) nothrow {
    alias da_glStartTilingQCOM = void function( GLuint, GLuint, GLuint, GLuint, GLbitfield );
    alias da_glEndTilingQCOM = void function( GLbitfield );
}
__gshared {
    da_glStartTilingQCOM glStartTilingQCOM;
    da_glEndTilingQCOM glEndTilingQCOM;
}
private void load_GL_QCOM_tiled_rendering() {
    try {
        bindGLFunc( cast( void** )&glStartTilingQCOM, "glStartTilingQCOM" );
        bindGLFunc( cast( void** )&glEndTilingQCOM, "glEndTilingQCOM" );

        _GL_QCOM_tiled_rendering = true;
    } catch( Exception e ) {
        _GL_QCOM_tiled_rendering = false;
    }
}

private __gshared bool _GL_QCOM_writeonly_rendering;
bool GL_QCOM_writeonly_rendering() @property { return _GL_QCOM_writeonly_rendering; }
enum : uint {
    GL_WRITEONLY_RENDERING_QCOM       = 0x8823,
}

private __gshared bool _GL_VIV_shader_binary;
bool GL_VIV_shader_binary() @property { return _GL_VIV_shader_binary; }
enum : uint {
    GL_SHADER_BINARY_VIV              = 0x8FC4,
}

package void loadEXT(  ) {
    _GL_KHR_blend_equation_advanced = isExtSupported( "GL_KHR_blend_equation_advanced" );
    if( _GL_KHR_blend_equation_advanced ) load_GL_KHR_blend_equation_advanced();
    _GL_KHR_debug = isExtSupported( "GL_KHR_debug" );
    if( _GL_KHR_debug ) load_GL_KHR_debug();
    _GL_KHR_texture_compression_astc_hdr = isExtSupported( "GL_KHR_texture_compression_astc_hdr" );
    _GL_KHR_texture_compression_astc_ldr = isExtSupported( "GL_KHR_texture_compression_astc_ldr" );
    _GL_OES_EGL_image = isExtSupported( "GL_OES_EGL_image" );
    if( _GL_OES_EGL_image ) load_GL_OES_EGL_image();
    _GL_OES_EGL_image_external = isExtSupported( "GL_OES_EGL_image_external" );
    _GL_OES_compressed_ETC1_RGB8_texture = isExtSupported( "GL_OES_compressed_ETC1_RGB8_texture" );
    _GL_OES_compressed_paletted_texture = isExtSupported( "GL_OES_compressed_paletted_texture" );
    _GL_OES_depth24 = isExtSupported( "GL_OES_depth24" );
    _GL_OES_depth32 = isExtSupported( "GL_OES_depth32" );
    _GL_OES_depth_texture = isExtSupported( "GL_OES_depth_texture" );
    _GL_OES_element_index_uint = isExtSupported( "GL_OES_element_index_uint" );
    _GL_OES_fbo_render_mipmap = isExtSupported( "GL_OES_fbo_render_mipmap" );
    _GL_OES_fragment_precision_high = isExtSupported( "GL_OES_fragment_precision_high" );
    _GL_OES_get_program_binary = isExtSupported( "GL_OES_get_program_binary" );
    if( _GL_OES_get_program_binary ) load_GL_OES_get_program_binary();
    _GL_OES_mapbuffer = isExtSupported( "GL_OES_mapbuffer" );
    if( _GL_OES_mapbuffer ) load_GL_OES_mapbuffer();
    _GL_OES_packed_depth_stencil = isExtSupported( "GL_OES_packed_depth_stencil" );
    _GL_OES_required_internalformat = isExtSupported( "GL_OES_required_internalformat" );
    _GL_OES_rgb8_rgba8 = isExtSupported( "GL_OES_rgb8_rgba8" );
    _GL_OES_sample_shading = isExtSupported( "GL_OES_sample_shading" );
    if( _GL_OES_sample_shading ) load_GL_OES_sample_shading();
    _GL_OES_sample_variables = isExtSupported( "GL_OES_sample_variables" );
    _GL_OES_shader_image_atomic = isExtSupported( "GL_OES_shader_image_atomic" );
    _GL_OES_shader_multisample_interpolation = isExtSupported( "GL_OES_shader_multisample_interpolation" );
    _GL_OES_standard_derivatives = isExtSupported( "GL_OES_standard_derivatives" );
    _GL_OES_stencil1 = isExtSupported( "GL_OES_stencil1" );
    _GL_OES_stencil4 = isExtSupported( "GL_OES_stencil4" );
    _GL_OES_surfaceless_context = isExtSupported( "GL_OES_surfaceless_context" );
    _GL_OES_texture_3D = isExtSupported( "GL_OES_texture_3D" );
    if( _GL_OES_texture_3D ) load_GL_OES_texture_3D();
    _GL_OES_texture_compression_astc = isExtSupported( "GL_OES_texture_compression_astc" );
    _GL_OES_texture_float = isExtSupported( "GL_OES_texture_float" );
    _GL_OES_texture_float_linear = isExtSupported( "GL_OES_texture_float_linear" );
    _GL_OES_texture_half_float = isExtSupported( "GL_OES_texture_half_float" );
    _GL_OES_texture_half_float_linear = isExtSupported( "GL_OES_texture_half_float_linear" );
    _GL_OES_texture_npot = isExtSupported( "GL_OES_texture_npot" );
    _GL_OES_texture_stencil8 = isExtSupported( "GL_OES_texture_stencil8" );
    _GL_OES_texture_storage_multisample_2d_array = isExtSupported( "GL_OES_texture_storage_multisample_2d_array" );
    if( _GL_OES_texture_storage_multisample_2d_array ) load_GL_OES_texture_storage_multisample_2d_array();
    _GL_OES_vertex_array_object = isExtSupported( "GL_OES_vertex_array_object" );
    if( _GL_OES_vertex_array_object ) load_GL_OES_vertex_array_object();
    _GL_OES_vertex_half_float = isExtSupported( "GL_OES_vertex_half_float" );
    _GL_OES_vertex_type_10_10_10_2 = isExtSupported( "GL_OES_vertex_type_10_10_10_2" );
    _GL_AMD_compressed_3DC_texture = isExtSupported( "GL_AMD_compressed_3DC_texture" );
    _GL_AMD_compressed_ATC_texture = isExtSupported( "GL_AMD_compressed_ATC_texture" );
    _GL_AMD_performance_monitor = isExtSupported( "GL_AMD_performance_monitor" );
    if( _GL_AMD_performance_monitor ) load_GL_AMD_performance_monitor();
    _GL_AMD_program_binary_Z400 = isExtSupported( "GL_AMD_program_binary_Z400" );
    _GL_ANGLE_depth_texture = isExtSupported( "GL_ANGLE_depth_texture" );
    _GL_ANGLE_framebuffer_blit = isExtSupported( "GL_ANGLE_framebuffer_blit" );
    if( _GL_ANGLE_framebuffer_blit ) load_GL_ANGLE_framebuffer_blit();
    _GL_ANGLE_framebuffer_multisample = isExtSupported( "GL_ANGLE_framebuffer_multisample" );
    if( _GL_ANGLE_framebuffer_multisample ) load_GL_ANGLE_framebuffer_multisample();
    _GL_ANGLE_instanced_arrays = isExtSupported( "GL_ANGLE_instanced_arrays" );
    if( _GL_ANGLE_instanced_arrays ) load_GL_ANGLE_instanced_arrays();
    _GL_ANGLE_pack_reverse_row_order = isExtSupported( "GL_ANGLE_pack_reverse_row_order" );
    _GL_ANGLE_program_binary = isExtSupported( "GL_ANGLE_program_binary" );
    _GL_ANGLE_texture_compression_dxt3 = isExtSupported( "GL_ANGLE_texture_compression_dxt3" );
    _GL_ANGLE_texture_compression_dxt5 = isExtSupported( "GL_ANGLE_texture_compression_dxt5" );
    _GL_ANGLE_texture_usage = isExtSupported( "GL_ANGLE_texture_usage" );
    _GL_ANGLE_translated_shader_source = isExtSupported( "GL_ANGLE_translated_shader_source" );
    if( _GL_ANGLE_translated_shader_source ) load_GL_ANGLE_translated_shader_source();
    _GL_APPLE_copy_texture_levels = isExtSupported( "GL_APPLE_copy_texture_levels" );
    if( _GL_APPLE_copy_texture_levels ) load_GL_APPLE_copy_texture_levels();
    _GL_APPLE_framebuffer_multisample = isExtSupported( "GL_APPLE_framebuffer_multisample" );
    if( _GL_APPLE_framebuffer_multisample ) load_GL_APPLE_framebuffer_multisample();
    _GL_APPLE_rgb_422 = isExtSupported( "GL_APPLE_rgb_422" );
    _GL_APPLE_sync = isExtSupported( "GL_APPLE_sync" );
    if( _GL_APPLE_sync ) load_GL_APPLE_sync();
    _GL_APPLE_texture_format_BGRA8888 = isExtSupported( "GL_APPLE_texture_format_BGRA8888" );
    _GL_APPLE_texture_max_level = isExtSupported( "GL_APPLE_texture_max_level" );
    _GL_ARM_mali_program_binary = isExtSupported( "GL_ARM_mali_program_binary" );
    _GL_ARM_mali_shader_binary = isExtSupported( "GL_ARM_mali_shader_binary" );
    _GL_ARM_rgba8 = isExtSupported( "GL_ARM_rgba8" );
    _GL_ARM_shader_framebuffer_fetch = isExtSupported( "GL_ARM_shader_framebuffer_fetch" );
    _GL_ARM_shader_framebuffer_fetch_depth_stencil = isExtSupported( "GL_ARM_shader_framebuffer_fetch_depth_stencil" );
    _GL_DMP_shader_binary = isExtSupported( "GL_DMP_shader_binary" );
    _GL_EXT_blend_minmax = isExtSupported( "GL_EXT_blend_minmax" );
    _GL_EXT_color_buffer_half_float = isExtSupported( "GL_EXT_color_buffer_half_float" );
    _GL_EXT_debug_label = isExtSupported( "GL_EXT_debug_label" );
    if( _GL_EXT_debug_label ) load_GL_EXT_debug_label();
    _GL_EXT_debug_marker = isExtSupported( "GL_EXT_debug_marker" );
    if( _GL_EXT_debug_marker ) load_GL_EXT_debug_marker();
    _GL_EXT_discard_framebuffer = isExtSupported( "GL_EXT_discard_framebuffer" );
    if( _GL_EXT_discard_framebuffer ) load_GL_EXT_discard_framebuffer();
    _GL_EXT_disjoint_timer_query = isExtSupported( "GL_EXT_disjoint_timer_query" );
    if( _GL_EXT_disjoint_timer_query ) load_GL_EXT_disjoint_timer_query();
    _GL_EXT_draw_buffers = isExtSupported( "GL_EXT_draw_buffers" );
    if( _GL_EXT_draw_buffers ) load_GL_EXT_draw_buffers();
    _GL_EXT_draw_instanced = isExtSupported( "GL_EXT_draw_instanced" );
    if( _GL_EXT_draw_instanced ) load_GL_EXT_draw_instanced();
    _GL_EXT_instanced_arrays = isExtSupported( "GL_EXT_instanced_arrays" );
    if( _GL_EXT_instanced_arrays ) load_GL_EXT_instanced_arrays();
    _GL_EXT_map_buffer_range = isExtSupported( "GL_EXT_map_buffer_range" );
    if( _GL_EXT_map_buffer_range ) load_GL_EXT_map_buffer_range();
    _GL_EXT_multi_draw_arrays = isExtSupported( "GL_EXT_multi_draw_arrays" );
    if( _GL_EXT_multi_draw_arrays ) load_GL_EXT_multi_draw_arrays();
    _GL_EXT_multisampled_render_to_texture = isExtSupported( "GL_EXT_multisampled_render_to_texture" );
    if( _GL_EXT_multisampled_render_to_texture ) load_GL_EXT_multisampled_render_to_texture();
    _GL_EXT_multiview_draw_buffers = isExtSupported( "GL_EXT_multiview_draw_buffers" );
    if( _GL_EXT_multiview_draw_buffers ) load_GL_EXT_multiview_draw_buffers();
    _GL_EXT_occlusion_query_boolean = isExtSupported( "GL_EXT_occlusion_query_boolean" );
    _GL_EXT_pvrtc_sRGB = isExtSupported( "GL_EXT_pvrtc_sRGB" );
    _GL_EXT_read_format_bgra = isExtSupported( "GL_EXT_read_format_bgra" );
    _GL_EXT_robustness = isExtSupported( "GL_EXT_robustness" );
    if( _GL_EXT_robustness ) load_GL_EXT_robustness();
    _GL_EXT_sRGB = isExtSupported( "GL_EXT_sRGB" );
    _GL_EXT_sRGB_write_control = isExtSupported( "GL_EXT_sRGB_write_control" );
    _GL_EXT_separate_shader_objects = isExtSupported( "GL_EXT_separate_shader_objects" );
    if( _GL_EXT_separate_shader_objects ) load_GL_EXT_separate_shader_objects();
    _GL_EXT_shader_framebuffer_fetch = isExtSupported( "GL_EXT_shader_framebuffer_fetch" );
    _GL_EXT_shader_integer_mix = isExtSupported( "GL_EXT_shader_integer_mix" );
    _GL_EXT_shader_pixel_local_storage = isExtSupported( "GL_EXT_shader_pixel_local_storage" );
    _GL_EXT_shader_texture_lod = isExtSupported( "GL_EXT_shader_texture_lod" );
    _GL_EXT_shadow_samplers = isExtSupported( "GL_EXT_shadow_samplers" );
    _GL_EXT_texture_compression_dxt1 = isExtSupported( "GL_EXT_texture_compression_dxt1" );
    _GL_EXT_texture_compression_s3tc = isExtSupported( "GL_EXT_texture_compression_s3tc" );
    _GL_EXT_texture_filter_anisotropic = isExtSupported( "GL_EXT_texture_filter_anisotropic" );
    _GL_EXT_texture_format_BGRA8888 = isExtSupported( "GL_EXT_texture_format_BGRA8888" );
    _GL_EXT_texture_rg = isExtSupported( "GL_EXT_texture_rg" );
    _GL_EXT_texture_sRGB_decode = isExtSupported( "GL_EXT_texture_sRGB_decode" );
    _GL_EXT_texture_storage = isExtSupported( "GL_EXT_texture_storage" );
    if( _GL_EXT_texture_storage ) load_GL_EXT_texture_storage();
    _GL_EXT_texture_type_2_10_10_10_REV = isExtSupported( "GL_EXT_texture_type_2_10_10_10_REV" );
    _GL_EXT_unpack_subimage = isExtSupported( "GL_EXT_unpack_subimage" );
    _GL_FJ_shader_binary_GCCSO = isExtSupported( "GL_FJ_shader_binary_GCCSO" );
    _GL_IMG_multisampled_render_to_texture = isExtSupported( "GL_IMG_multisampled_render_to_texture" );
    if( _GL_IMG_multisampled_render_to_texture ) load_GL_IMG_multisampled_render_to_texture();
    _GL_IMG_program_binary = isExtSupported( "GL_IMG_program_binary" );
    _GL_IMG_read_format = isExtSupported( "GL_IMG_read_format" );
    _GL_IMG_shader_binary = isExtSupported( "GL_IMG_shader_binary" );
    _GL_IMG_texture_compression_pvrtc = isExtSupported( "GL_IMG_texture_compression_pvrtc" );
    _GL_IMG_texture_compression_pvrtc2 = isExtSupported( "GL_IMG_texture_compression_pvrtc2" );
    _GL_INTEL_performance_query = isExtSupported( "GL_INTEL_performance_query" );
    if( _GL_INTEL_performance_query ) load_GL_INTEL_performance_query();
    _GL_NV_blend_equation_advanced = isExtSupported( "GL_NV_blend_equation_advanced" );
    if( _GL_NV_blend_equation_advanced ) load_GL_NV_blend_equation_advanced();
    _GL_NV_blend_equation_advanced_coherent = isExtSupported( "GL_NV_blend_equation_advanced_coherent" );
    _GL_NV_copy_buffer = isExtSupported( "GL_NV_copy_buffer" );
    if( _GL_NV_copy_buffer ) load_GL_NV_copy_buffer();
    _GL_NV_coverage_sample = isExtSupported( "GL_NV_coverage_sample" );
    if( _GL_NV_coverage_sample ) load_GL_NV_coverage_sample();
    _GL_NV_depth_nonlinear = isExtSupported( "GL_NV_depth_nonlinear" );
    _GL_NV_draw_buffers = isExtSupported( "GL_NV_draw_buffers" );
    if( _GL_NV_draw_buffers ) load_GL_NV_draw_buffers();
    _GL_NV_draw_instanced = isExtSupported( "GL_NV_draw_instanced" );
    if( _GL_NV_draw_instanced ) load_GL_NV_draw_instanced();
    _GL_NV_explicit_attrib_location = isExtSupported( "GL_NV_explicit_attrib_location" );
    _GL_NV_fbo_color_attachments = isExtSupported( "GL_NV_fbo_color_attachments" );
    _GL_NV_fence = isExtSupported( "GL_NV_fence" );
    if( _GL_NV_fence ) load_GL_NV_fence();
    _GL_NV_framebuffer_blit = isExtSupported( "GL_NV_framebuffer_blit" );
    if( _GL_NV_framebuffer_blit ) load_GL_NV_framebuffer_blit();
    _GL_NV_framebuffer_multisample = isExtSupported( "GL_NV_framebuffer_multisample" );
    if( _GL_NV_framebuffer_multisample ) load_GL_NV_framebuffer_multisample();
    _GL_NV_generate_mipmap_sRGB = isExtSupported( "GL_NV_generate_mipmap_sRGB" );
    _GL_NV_instanced_arrays = isExtSupported( "GL_NV_instanced_arrays" );
    if( _GL_NV_instanced_arrays ) load_GL_NV_instanced_arrays();
    _GL_NV_non_square_matrices = isExtSupported( "GL_NV_non_square_matrices" );
    if( _GL_NV_non_square_matrices ) load_GL_NV_non_square_matrices();
    _GL_NV_read_buffer = isExtSupported( "GL_NV_read_buffer" );
    _GL_NV_read_buffer_front = isExtSupported( "GL_NV_read_buffer_front" );
    _GL_NV_read_depth = isExtSupported( "GL_NV_read_depth" );
    _GL_NV_read_depth_stencil = isExtSupported( "GL_NV_read_depth_stencil" );
    _GL_NV_read_stencil = isExtSupported( "GL_NV_read_stencil" );
    _GL_NV_sRGB_formats = isExtSupported( "GL_NV_sRGB_formats" );
    _GL_NV_shadow_samplers_array = isExtSupported( "GL_NV_shadow_samplers_array" );
    _GL_NV_shadow_samplers_cube = isExtSupported( "GL_NV_shadow_samplers_cube" );
    _GL_NV_texture_border_clamp = isExtSupported( "GL_NV_texture_border_clamp" );
    _GL_NV_texture_compression_s3tc_update = isExtSupported( "GL_NV_texture_compression_s3tc_update" );
    _GL_NV_texture_npot_2D_mipmap = isExtSupported( "GL_NV_texture_npot_2D_mipmap" );
    _GL_QCOM_alpha_test = isExtSupported( "GL_QCOM_alpha_test" );
    if( _GL_QCOM_alpha_test ) load_GL_QCOM_alpha_test();
    _GL_QCOM_binning_control = isExtSupported( "GL_QCOM_binning_control" );
    _GL_QCOM_driver_control = isExtSupported( "GL_QCOM_driver_control" );
    if( _GL_QCOM_driver_control ) load_GL_QCOM_driver_control();
    _GL_QCOM_extended_get = isExtSupported( "GL_QCOM_extended_get" );
    if( _GL_QCOM_extended_get ) load_GL_QCOM_extended_get();
    _GL_QCOM_extended_get2 = isExtSupported( "GL_QCOM_extended_get2" );
    if( _GL_QCOM_extended_get2 ) load_GL_QCOM_extended_get2();
    _GL_QCOM_perfmon_global_mode = isExtSupported( "GL_QCOM_perfmon_global_mode" );
    _GL_QCOM_tiled_rendering = isExtSupported( "GL_QCOM_tiled_rendering" );
    if( _GL_QCOM_tiled_rendering ) load_GL_QCOM_tiled_rendering();
    _GL_QCOM_writeonly_rendering = isExtSupported( "GL_QCOM_writeonly_rendering" );
    _GL_VIV_shader_binary = isExtSupported( "GL_VIV_shader_binary" );
}
