/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.gles.eglext;

private {
    import derelict.gles.egltypes;
    import derelict.gles.internal;
    import core.stdc.stdint;
}

private __gshared bool _EGL_KHR_cl_event;
bool EGL_KHR_cl_event() @property { return _EGL_KHR_cl_event; }
enum : uint {
    EGL_CL_EVENT_HANDLE_KHR           = 0x309C,
    EGL_SYNC_CL_EVENT_KHR             = 0x30FE,
    EGL_SYNC_CL_EVENT_COMPLETE_KHR    = 0x30FF,
}

private __gshared bool _EGL_KHR_cl_event2;
bool EGL_KHR_cl_event2() @property { return _EGL_KHR_cl_event2; }
alias EGLSyncKHR = void*;
alias EGLAttribKHR = intptr_t;
extern( System ) nothrow {
    alias EGLSyncKHR function( EGLDisplay, EGLenum, const EGLAttribKHR* ) da_eglCreateSync64KHR;
}
__gshared {
    da_eglCreateSync64KHR eglCreateSync64KHR;
}
private void load_EGL_KHR_cl_event2() {
    try {
        bindGLFunc( cast( void** )&eglCreateSync64KHR, "eglCreateSync64KHR" );

        _EGL_KHR_cl_event2 = true;
    } catch( Exception e ) {
        _EGL_KHR_cl_event2 = false;
    }
}

private __gshared bool _EGL_KHR_client_get_all_proc_addresses;
bool EGL_KHR_client_get_all_proc_addresses() @property { return _EGL_KHR_client_get_all_proc_addresses; }

private __gshared bool _EGL_KHR_config_attribs;
bool EGL_KHR_config_attribs() @property { return _EGL_KHR_config_attribs; }
enum : uint {
    EGL_CONFORMANT_KHR                = 0x3042,
    EGL_VG_COLORSPACE_LINEAR_BIT_KHR  = 0x0020,
    EGL_VG_ALPHA_FORMAT_PRE_BIT_KHR   = 0x0040,
}

private __gshared bool _EGL_KHR_create_context;
bool EGL_KHR_create_context() @property { return _EGL_KHR_create_context; }
enum : uint {
    EGL_CONTEXT_MAJOR_VERSION_KHR     = 0x3098,
    EGL_CONTEXT_MINOR_VERSION_KHR     = 0x30FB,
    EGL_CONTEXT_FLAGS_KHR             = 0x30FC,
    EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR = 0x30FD,
    EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR = 0x31BD,
    EGL_NO_RESET_NOTIFICATION_KHR     = 0x31BE,
    EGL_LOSE_CONTEXT_ON_RESET_KHR     = 0x31BF,
    EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR  = 0x00000001,
    EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR = 0x00000002,
    EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR = 0x00000004,
    EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR = 0x00000001,
    EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR = 0x00000002,
    EGL_OPENGL_ES3_BIT_KHR            = 0x00000040,
}

private __gshared bool _EGL_KHR_fence_sync;
bool EGL_KHR_fence_sync() @property { return _EGL_KHR_fence_sync; }
enum : uint {
    EGL_SYNC_PRIOR_COMMANDS_COMPLETE_KHR = 0x30F0,
    EGL_SYNC_CONDITION_KHR            = 0x30F8,
    EGL_SYNC_FENCE_KHR                = 0x30F9,
}

private __gshared bool _EGL_KHR_get_all_proc_addresses;
bool EGL_KHR_get_all_proc_addresses() @property { return _EGL_KHR_get_all_proc_addresses; }

private __gshared bool _EGL_KHR_gl_colorspace;
bool EGL_KHR_gl_colorspace() @property { return _EGL_KHR_gl_colorspace; }
enum : uint {
    EGL_GL_COLORSPACE_KHR             = 0x309D,
    EGL_GL_COLORSPACE_SRGB_KHR        = 0x3089,
    EGL_GL_COLORSPACE_LINEAR_KHR      = 0x308A,
}

private __gshared bool _EGL_KHR_gl_renderbuffer_image;
bool EGL_KHR_gl_renderbuffer_image() @property { return _EGL_KHR_gl_renderbuffer_image; }
enum : uint {
    EGL_GL_RENDERBUFFER_KHR           = 0x30B9,
}

private __gshared bool _EGL_KHR_gl_texture_2D_image;
bool EGL_KHR_gl_texture_2D_image() @property { return _EGL_KHR_gl_texture_2D_image; }
enum : uint {
    EGL_GL_TEXTURE_2D_KHR             = 0x30B1,
    EGL_GL_TEXTURE_LEVEL_KHR          = 0x30BC,
}

private __gshared bool _EGL_KHR_gl_texture_3D_image;
bool EGL_KHR_gl_texture_3D_image() @property { return _EGL_KHR_gl_texture_3D_image; }
enum : uint {
    EGL_GL_TEXTURE_3D_KHR             = 0x30B2,
    EGL_GL_TEXTURE_ZOFFSET_KHR        = 0x30BD,
}

private __gshared bool _EGL_KHR_gl_texture_cubemap_image;
bool EGL_KHR_gl_texture_cubemap_image() @property { return _EGL_KHR_gl_texture_cubemap_image; }
enum : uint {
    EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR = 0x30B3,
    EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR = 0x30B4,
    EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR = 0x30B5,
    EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR = 0x30B6,
    EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR = 0x30B7,
    EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR = 0x30B8,
}

private __gshared bool _EGL_KHR_image;
bool EGL_KHR_image() @property { return _EGL_KHR_image; }
alias EGLImageKHR = void*;
enum EGLImageKHR EGL_NO_IMAGE_KHR = null;
enum : uint {
    EGL_NATIVE_PIXMAP_KHR             = 0x30B0,
}
extern( System ) nothrow {
    alias EGLImageKHR function( EGLDisplay, EGLContext, EGLenum, EGLClientBuffer, const EGLint* ) da_eglCreateImageKHR;
    alias EGLBoolean function( EGLDisplay, EGLImageKHR ) da_eglDestroyImageKHR;
}
__gshared {
    da_eglCreateImageKHR eglCreateImageKHR;
    da_eglDestroyImageKHR eglDestroyImageKHR;
}
private void load_EGL_KHR_image() {
    try {
        bindGLFunc( cast( void** )&eglCreateImageKHR, "eglCreateImageKHR" );
        bindGLFunc( cast( void** )&eglDestroyImageKHR, "eglDestroyImageKHR" );

        _EGL_KHR_image = true;
    } catch( Exception e ) {
        _EGL_KHR_image = false;
    }
}

private __gshared bool _EGL_KHR_image_base;
bool EGL_KHR_image_base() @property { return _EGL_KHR_image_base; }
enum : uint {
    EGL_IMAGE_PRESERVED_KHR           = 0x30D2,
}

private __gshared bool _EGL_KHR_image_pixmap;
bool EGL_KHR_image_pixmap() @property { return _EGL_KHR_image_pixmap; }

private __gshared bool _EGL_KHR_lock_surface;
bool EGL_KHR_lock_surface() @property { return _EGL_KHR_lock_surface; }
enum : uint {
    EGL_READ_SURFACE_BIT_KHR          = 0x0001,
    EGL_WRITE_SURFACE_BIT_KHR         = 0x0002,
    EGL_LOCK_SURFACE_BIT_KHR          = 0x0080,
    EGL_OPTIMAL_FORMAT_BIT_KHR        = 0x0100,
    EGL_MATCH_FORMAT_KHR              = 0x3043,
    EGL_FORMAT_RGB_565_EXACT_KHR      = 0x30C0,
    EGL_FORMAT_RGB_565_KHR            = 0x30C1,
    EGL_FORMAT_RGBA_8888_EXACT_KHR    = 0x30C2,
    EGL_FORMAT_RGBA_8888_KHR          = 0x30C3,
    EGL_MAP_PRESERVE_PIXELS_KHR       = 0x30C4,
    EGL_LOCK_USAGE_HINT_KHR           = 0x30C5,
    EGL_BITMAP_POINTER_KHR            = 0x30C6,
    EGL_BITMAP_PITCH_KHR              = 0x30C7,
    EGL_BITMAP_ORIGIN_KHR             = 0x30C8,
    EGL_BITMAP_PIXEL_RED_OFFSET_KHR   = 0x30C9,
    EGL_BITMAP_PIXEL_GREEN_OFFSET_KHR = 0x30CA,
    EGL_BITMAP_PIXEL_BLUE_OFFSET_KHR  = 0x30CB,
    EGL_BITMAP_PIXEL_ALPHA_OFFSET_KHR = 0x30CC,
    EGL_BITMAP_PIXEL_LUMINANCE_OFFSET_KHR = 0x30CD,
    EGL_LOWER_LEFT_KHR                = 0x30CE,
    EGL_UPPER_LEFT_KHR                = 0x30CF,
}
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLSurface, const EGLint* ) da_eglLockSurfaceKHR;
    alias EGLBoolean function( EGLDisplay, EGLSurface ) da_eglUnlockSurfaceKHR;
}
__gshared {
    da_eglLockSurfaceKHR eglLockSurfaceKHR;
    da_eglUnlockSurfaceKHR eglUnlockSurfaceKHR;
}
private void load_EGL_KHR_lock_surface() {
    try {
        bindGLFunc( cast( void** )&eglLockSurfaceKHR, "eglLockSurfaceKHR" );
        bindGLFunc( cast( void** )&eglUnlockSurfaceKHR, "eglUnlockSurfaceKHR" );

        _EGL_KHR_lock_surface = true;
    } catch( Exception e ) {
        _EGL_KHR_lock_surface = false;
    }
}

private __gshared bool _EGL_KHR_lock_surface2;
bool EGL_KHR_lock_surface2() @property { return _EGL_KHR_lock_surface2; }
enum : uint {
    EGL_BITMAP_PIXEL_SIZE_KHR         = 0x3110,
}

private __gshared bool _EGL_KHR_lock_surface3;
bool EGL_KHR_lock_surface3() @property { return _EGL_KHR_lock_surface3; }
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLSurface, EGLint, EGLAttribKHR* ) da_eglQuerySurface64KHR;
}
__gshared {
    da_eglQuerySurface64KHR eglQuerySurface64KHR;
}
private void load_EGL_KHR_lock_surface3() {
    try {
        bindGLFunc( cast( void** )&eglQuerySurface64KHR, "eglQuerySurface64KHR" );

        _EGL_KHR_lock_surface3 = true;
    } catch( Exception e ) {
        _EGL_KHR_lock_surface3 = false;
    }
}

private __gshared bool _EGL_KHR_platform_android;
bool EGL_KHR_platform_android() @property { return _EGL_KHR_platform_android; }
enum : uint {
    EGL_PLATFORM_ANDROID_KHR          = 0x3141,
}

private __gshared bool _EGL_KHR_platform_gbm;
bool EGL_KHR_platform_gbm() @property { return _EGL_KHR_platform_gbm; }
enum : uint {
    EGL_PLATFORM_GBM_KHR              = 0x31D7,
}

private __gshared bool _EGL_KHR_platform_wayland;
bool EGL_KHR_platform_wayland() @property { return _EGL_KHR_platform_wayland; }
enum : uint {
    EGL_PLATFORM_WAYLAND_KHR          = 0x31D8,
}

private __gshared bool _EGL_KHR_platform_x11;
bool EGL_KHR_platform_x11() @property { return _EGL_KHR_platform_x11; }
enum : uint {
    EGL_PLATFORM_X11_KHR              = 0x31D5,
    EGL_PLATFORM_X11_SCREEN_KHR       = 0x31D6,
}

private __gshared bool _EGL_KHR_reusable_sync;
bool EGL_KHR_reusable_sync() @property { return _EGL_KHR_reusable_sync; }
alias EGLTimeKHR = ulong;
enum EGLTimeKHR EGL_FOREVER_KHR = 0xFFFFFFFFFFFFFFFFUL;
enum EGLSyncKHR EGL_NO_SYNC_KHR = null;
enum : uint {
    EGL_SYNC_STATUS_KHR               = 0x30F1,
    EGL_SIGNALED_KHR                  = 0x30F2,
    EGL_UNSIGNALED_KHR                = 0x30F3,
    EGL_TIMEOUT_EXPIRED_KHR           = 0x30F5,
    EGL_CONDITION_SATISFIED_KHR       = 0x30F6,
    EGL_SYNC_TYPE_KHR                 = 0x30F7,
    EGL_SYNC_REUSABLE_KHR             = 0x30FA,
    EGL_SYNC_FLUSH_COMMANDS_BIT_KHR   = 0x0001,
}
extern( System ) nothrow {
    alias EGLSyncKHR function( EGLDisplay, EGLenum, const EGLint* ) da_eglCreateSyncKHR;
    alias EGLBoolean function( EGLDisplay, EGLSyncKHR ) da_eglDestroySyncKHR;
    alias EGLint function( EGLDisplay, EGLSyncKHR, EGLint, EGLTimeKHR ) da_eglClientWaitSyncKHR;
    alias EGLBoolean function( EGLDisplay, EGLSyncKHR, EGLenum ) da_eglSignalSyncKHR;
    alias EGLBoolean function( EGLDisplay, EGLSyncKHR, EGLint, EGLint* ) da_eglGetSyncAttribKHR;
}
__gshared {
    da_eglCreateSyncKHR eglCreateSyncKHR;
    da_eglDestroySyncKHR eglDestroySyncKHR;
    da_eglClientWaitSyncKHR eglClientWaitSyncKHR;
    da_eglSignalSyncKHR eglSignalSyncKHR;
    da_eglGetSyncAttribKHR eglGetSyncAttribKHR;
}
private void load_EGL_KHR_reusable_sync() {
    try {
        bindGLFunc( cast( void** )&eglCreateSyncKHR, "eglCreateSyncKHR" );
        bindGLFunc( cast( void** )&eglDestroySyncKHR, "eglDestroySyncKHR" );
        bindGLFunc( cast( void** )&eglClientWaitSyncKHR, "eglClientWaitSyncKHR" );
        bindGLFunc( cast( void** )&eglSignalSyncKHR, "eglSignalSyncKHR" );
        bindGLFunc( cast( void** )&eglGetSyncAttribKHR, "eglGetSyncAttribKHR" );

        _EGL_KHR_reusable_sync = true;
    } catch( Exception e ) {
        _EGL_KHR_reusable_sync = false;
    }
}

private __gshared bool _EGL_KHR_stream;
bool EGL_KHR_stream() @property { return _EGL_KHR_stream; }
alias EGLStreamKHR = void*;
alias EGLuint64KHR = ulong;
enum EGLStreamKHR EGL_NO_STREAM_KHR = null;
enum : uint {
    EGL_CONSUMER_LATENCY_USEC_KHR     = 0x3210,
    EGL_PRODUCER_FRAME_KHR            = 0x3212,
    EGL_CONSUMER_FRAME_KHR            = 0x3213,
    EGL_STREAM_STATE_KHR              = 0x3214,
    EGL_STREAM_STATE_CREATED_KHR      = 0x3215,
    EGL_STREAM_STATE_CONNECTING_KHR   = 0x3216,
    EGL_STREAM_STATE_EMPTY_KHR        = 0x3217,
    EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR = 0x3218,
    EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR = 0x3219,
    EGL_STREAM_STATE_DISCONNECTED_KHR = 0x321A,
    EGL_BAD_STREAM_KHR                = 0x321B,
    EGL_BAD_STATE_KHR                 = 0x321C,
}
extern( System ) nothrow {
    alias EGLStreamKHR function( EGLDisplay, const EGLint* ) da_eglCreateStreamKHR;
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR ) da_eglDestroyStreamKHR;
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR, EGLenum, EGLint ) da_eglStreamAttribKHR;
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR, EGLenum, EGLint* ) da_eglQueryStreamKHR;
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR, EGLenum, EGLuint64KHR* ) da_eglQueryStreamu64KHR;
}
__gshared {
    da_eglCreateStreamKHR eglCreateStreamKHR;
    da_eglDestroyStreamKHR eglDestroyStreamKHR;
    da_eglStreamAttribKHR eglStreamAttribKHR;
    da_eglQueryStreamKHR eglQueryStreamKHR;
    da_eglQueryStreamu64KHR eglQueryStreamu64KHR;
}
private void load_EGL_KHR_stream() {
    try {
        bindGLFunc( cast( void** )&eglCreateStreamKHR, "eglCreateStreamKHR" );
        bindGLFunc( cast( void** )&eglDestroyStreamKHR, "eglDestroyStreamKHR" );
        bindGLFunc( cast( void** )&eglStreamAttribKHR, "eglStreamAttribKHR" );
        bindGLFunc( cast( void** )&eglQueryStreamKHR, "eglQueryStreamKHR" );
        bindGLFunc( cast( void** )&eglQueryStreamu64KHR, "eglQueryStreamu64KHR" );

        _EGL_KHR_stream = true;
    } catch( Exception e ) {
        _EGL_KHR_stream = false;
    }
}

private __gshared bool _EGL_KHR_stream_consumer_gltexture;
bool EGL_KHR_stream_consumer_gltexture() @property { return _EGL_KHR_stream_consumer_gltexture; }
enum : uint {
    EGL_CONSUMER_ACQUIRE_TIMEOUT_USEC_KHR = 0x321E,
}
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR ) da_eglStreamConsumerGLTextureExternalKHR;
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR ) da_eglStreamConsumerAcquireKHR;
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR ) da_eglStreamConsumerReleaseKHR;
}
__gshared {
    da_eglStreamConsumerGLTextureExternalKHR eglStreamConsumerGLTextureExternalKHR;
    da_eglStreamConsumerAcquireKHR eglStreamConsumerAcquireKHR;
    da_eglStreamConsumerReleaseKHR eglStreamConsumerReleaseKHR;
}
private void load_EGL_KHR_stream_consumer_gltexture() {
    try {
        bindGLFunc( cast( void** )&eglStreamConsumerGLTextureExternalKHR, "eglStreamConsumerGLTextureExternalKHR" );
        bindGLFunc( cast( void** )&eglStreamConsumerAcquireKHR, "eglStreamConsumerAcquireKHR" );
        bindGLFunc( cast( void** )&eglStreamConsumerReleaseKHR, "eglStreamConsumerReleaseKHR" );

        _EGL_KHR_stream_consumer_gltexture = true;
    } catch( Exception e ) {
        _EGL_KHR_stream_consumer_gltexture = false;
    }
}

private __gshared bool _EGL_KHR_stream_cross_process_fd;
bool EGL_KHR_stream_cross_process_fd() @property { return _EGL_KHR_stream_cross_process_fd; }
alias EGLNativeFileDescriptorKHR = int;
enum EGLNativeFileDescriptorKHR EGL_NO_FILE_DESCRIPTOR_KHR = -1;
EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR( EGLDisplay, EGLStreamKHR );
EGLStreamKHR eglCreateStreamFromFileDescriptorKHR( EGLDisplay, EGLNativeFileDescriptorKHR );

private __gshared bool _EGL_KHR_stream_fifo;
bool EGL_KHR_stream_fifo() @property { return _EGL_KHR_stream_fifo; }
enum : uint {
    EGL_STREAM_FIFO_LENGTH_KHR        = 0x31FC,
    EGL_STREAM_TIME_NOW_KHR           = 0x31FD,
    EGL_STREAM_TIME_CONSUMER_KHR      = 0x31FE,
    EGL_STREAM_TIME_PRODUCER_KHR      = 0x31FF,
}
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLStreamKHR, EGLenum, EGLTimeKHR* ) da_eglQueryStreamTimeKHR;
}
__gshared {
    da_eglQueryStreamTimeKHR eglQueryStreamTimeKHR;
}
private void load_EGL_KHR_stream_fifo() {
    try {
        bindGLFunc( cast( void** )&eglQueryStreamTimeKHR, "eglQueryStreamTimeKHR" );

        _EGL_KHR_stream_fifo = true;
    } catch( Exception e ) {
        _EGL_KHR_stream_fifo = false;
    }
}

private __gshared bool _EGL_KHR_stream_producer_aldatalocator;
bool EGL_KHR_stream_producer_aldatalocator() @property { return _EGL_KHR_stream_producer_aldatalocator; }

private __gshared bool _EGL_KHR_stream_producer_eglsurface;
bool EGL_KHR_stream_producer_eglsurface() @property { return _EGL_KHR_stream_producer_eglsurface; }
enum : uint {
    EGL_STREAM_BIT_KHR                = 0x0800,
}
extern( System ) nothrow {
    alias EGLSurface function( EGLDisplay, EGLConfig, EGLStreamKHR, const EGLint* ) da_eglCreateStreamProducerSurfaceKHR;
}
__gshared {
    da_eglCreateStreamProducerSurfaceKHR eglCreateStreamProducerSurfaceKHR;
}
private void load_EGL_KHR_stream_producer_eglsurface() {
    try {
        bindGLFunc( cast( void** )&eglCreateStreamProducerSurfaceKHR, "eglCreateStreamProducerSurfaceKHR" );

        _EGL_KHR_stream_producer_eglsurface = true;
    } catch( Exception e ) {
        _EGL_KHR_stream_producer_eglsurface = false;
    }
}

private __gshared bool _EGL_KHR_surfaceless_context;
bool EGL_KHR_surfaceless_context() @property { return _EGL_KHR_surfaceless_context; }

private __gshared bool _EGL_KHR_vg_parent_image;
bool EGL_KHR_vg_parent_image() @property { return _EGL_KHR_vg_parent_image; }
enum : uint {
    EGL_VG_PARENT_IMAGE_KHR           = 0x30BA,
}

private __gshared bool _EGL_KHR_wait_sync;
bool EGL_KHR_wait_sync() @property { return _EGL_KHR_wait_sync; }
extern( System ) nothrow {
    alias EGLint function( EGLDisplay, EGLSyncKHR, EGLint ) da_eglWaitSyncKHR;
}
__gshared {
    da_eglWaitSyncKHR eglWaitSyncKHR;
}
private void load_EGL_KHR_wait_sync() {
    try {
        bindGLFunc( cast( void** )&eglWaitSyncKHR, "eglWaitSyncKHR" );

        _EGL_KHR_wait_sync = true;
    } catch( Exception e ) {
        _EGL_KHR_wait_sync = false;
    }
}

private __gshared bool _EGL_ANDROID_blob_cache;
bool EGL_ANDROID_blob_cache() @property { return _EGL_ANDROID_blob_cache; }
alias EGLsizeiANDROID = intptr_t;
alias void function( const void*, EGLsizeiANDROID, const void*, EGLsizeiANDROID ) EGLSetBlobFuncANDROID;
alias void function( const void*, EGLsizeiANDROID, const void*, EGLsizeiANDROID ) EGLGetBlobFuncANDROID;
extern( System ) nothrow {
    alias void function( EGLDisplay, EGLSetBlobFuncANDROID, EGLGetBlobFuncANDROID ) da_eglSetBlobCacheFuncsANDROID;
}
__gshared {
    da_eglSetBlobCacheFuncsANDROID eglSetBlobCacheFuncsANDROID;
}
private void load_EGL_ANDROID_blob_cache() {
    try {
        bindGLFunc( cast( void** )&eglSetBlobCacheFuncsANDROID, "eglSetBlobCacheFuncsANDROID" );

        _EGL_ANDROID_blob_cache = true;
    } catch( Exception e ) {
        _EGL_ANDROID_blob_cache = false;
    }
}

private __gshared bool _EGL_ANDROID_framebuffer_target;
bool EGL_ANDROID_framebuffer_target() @property { return _EGL_ANDROID_framebuffer_target; }
enum : uint {
    EGL_FRAMEBUFFER_TARGET_ANDROID    = 0x3147,
}

private __gshared bool _EGL_ANDROID_image_native_buffer;
bool EGL_ANDROID_image_native_buffer() @property { return _EGL_ANDROID_image_native_buffer; }
enum : uint {
    EGL_NATIVE_BUFFER_ANDROID         = 0x3140,
}

private __gshared bool _EGL_ANDROID_native_fence_sync;
bool EGL_ANDROID_native_fence_sync() @property { return _EGL_ANDROID_native_fence_sync; }
enum int EGL_NO_NATIVE_FENCE_ANDROID = -1;
enum : uint {
    EGL_SYNC_NATIVE_FENCE_ANDROID     = 0x3144,
    EGL_SYNC_NATIVE_FENCE_FD_ANDROID  = 0x3145,
    EGL_SYNC_NATIVE_FENCE_SIGNALED_ANDROID = 0x3146,
}
extern( System ) nothrow {
    alias EGLint function( EGLDisplay, EGLSyncKHR ) da_eglDupNativeFenceFDANDROID;
}
__gshared {
    da_eglDupNativeFenceFDANDROID eglDupNativeFenceFDANDROID;
}
private void load_EGL_ANDROID_native_fence_sync() {
    try {
        bindGLFunc( cast( void** )&eglDupNativeFenceFDANDROID, "eglDupNativeFenceFDANDROID" );

        _EGL_ANDROID_native_fence_sync = true;
    } catch( Exception e ) {
        _EGL_ANDROID_native_fence_sync = false;
    }
}

private __gshared bool _EGL_ANDROID_recordable;
bool EGL_ANDROID_recordable() @property { return _EGL_ANDROID_recordable; }
enum : uint {
    EGL_RECORDABLE_ANDROID            = 0x3142,
}

private __gshared bool _EGL_ANGLE_d3d_share_handle_client_buffer;
bool EGL_ANGLE_d3d_share_handle_client_buffer() @property { return _EGL_ANGLE_d3d_share_handle_client_buffer; }
enum : uint {
    EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE = 0x3200,
}

private __gshared bool _EGL_ANGLE_query_surface_pointer;
bool EGL_ANGLE_query_surface_pointer() @property { return _EGL_ANGLE_query_surface_pointer; }
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLSurface, EGLint, void** ) da_eglQuerySurfacePointerANGLE;
}
__gshared {
    da_eglQuerySurfacePointerANGLE eglQuerySurfacePointerANGLE;
}
private void load_EGL_ANGLE_query_surface_pointer() {
    try {
        bindGLFunc( cast( void** )&eglQuerySurfacePointerANGLE, "eglQuerySurfacePointerANGLE" );

        _EGL_ANGLE_query_surface_pointer = true;
    } catch( Exception e ) {
        _EGL_ANGLE_query_surface_pointer = false;
    }
}

private __gshared bool _EGL_ANGLE_surface_d3d_texture_2d_share_handle;
bool EGL_ANGLE_surface_d3d_texture_2d_share_handle() @property { return _EGL_ANGLE_surface_d3d_texture_2d_share_handle; }

private __gshared bool _EGL_ARM_pixmap_multisample_discard;
bool EGL_ARM_pixmap_multisample_discard() @property { return _EGL_ARM_pixmap_multisample_discard; }
enum : uint {
    EGL_DISCARD_SAMPLES_ARM           = 0x3286,
}

private __gshared bool _EGL_EXT_buffer_age;
bool EGL_EXT_buffer_age() @property { return _EGL_EXT_buffer_age; }
enum : uint {
    EGL_BUFFER_AGE_EXT                = 0x313D,
}

private __gshared bool _EGL_EXT_client_extensions;
bool EGL_EXT_client_extensions() @property { return _EGL_EXT_client_extensions; }

private __gshared bool _EGL_EXT_create_context_robustness;
bool EGL_EXT_create_context_robustness() @property { return _EGL_EXT_create_context_robustness; }
enum : uint {
    EGL_CONTEXT_OPENGL_ROBUST_ACCESS_EXT = 0x30BF,
    EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT = 0x3138,
    EGL_NO_RESET_NOTIFICATION_EXT     = 0x31BE,
    EGL_LOSE_CONTEXT_ON_RESET_EXT     = 0x31BF,
}

private __gshared bool _EGL_EXT_device_base;
bool EGL_EXT_device_base() @property { return _EGL_EXT_device_base; }
alias EGLDeviceEXT = void*;
enum EGLDeviceEXT EGL_NO_DEVICE_EXT = null;
enum : uint {
    EGL_BAD_DEVICE_EXT                = 0x322B,
    EGL_DEVICE_EXT                    = 0x322C,
}
extern( System ) nothrow {
    alias EGLBoolean function( EGLDeviceEXT, EGLint, EGLAttrib* ) da_eglQueryDeviceAttribEXT;
    alias const( char )* function( EGLDeviceEXT, EGLint ) da_eglQueryDeviceStringEXT;
    alias EGLBoolean function( EGLint, EGLDeviceEXT*, EGLint* ) da_eglQueryDevicesEXT;
    alias EGLBoolean function( EGLDisplay, EGLint, EGLAttrib* ) da_eglQueryDisplayAttribEXT;
}
__gshared {
    da_eglQueryDeviceAttribEXT eglQueryDeviceAttribEXT;
    da_eglQueryDeviceStringEXT eglQueryDeviceStringEXT;
    da_eglQueryDevicesEXT eglQueryDevicesEXT;
    da_eglQueryDisplayAttribEXT eglQueryDisplayAttribEXT;
}
private void load_EGL_EXT_device_base() {
    try {
        bindGLFunc( cast( void** )&eglQueryDeviceAttribEXT, "eglQueryDeviceAttribEXT" );
        bindGLFunc( cast( void** )&eglQueryDeviceStringEXT, "eglQueryDeviceStringEXT" );
        bindGLFunc( cast( void** )&eglQueryDevicesEXT, "eglQueryDevicesEXT" );
        bindGLFunc( cast( void** )&eglQueryDisplayAttribEXT, "eglQueryDisplayAttribEXT" );

        _EGL_EXT_device_base = true;
    } catch( Exception e ) {
        _EGL_EXT_device_base = false;
    }
}

private __gshared bool _EGL_EXT_image_dma_buf_import;
bool EGL_EXT_image_dma_buf_import() @property { return _EGL_EXT_image_dma_buf_import; }
enum : uint {
    EGL_LINUX_DMA_BUF_EXT             = 0x3270,
    EGL_LINUX_DRM_FOURCC_EXT          = 0x3271,
    EGL_DMA_BUF_PLANE0_FD_EXT         = 0x3272,
    EGL_DMA_BUF_PLANE0_OFFSET_EXT     = 0x3273,
    EGL_DMA_BUF_PLANE0_PITCH_EXT      = 0x3274,
    EGL_DMA_BUF_PLANE1_FD_EXT         = 0x3275,
    EGL_DMA_BUF_PLANE1_OFFSET_EXT     = 0x3276,
    EGL_DMA_BUF_PLANE1_PITCH_EXT      = 0x3277,
    EGL_DMA_BUF_PLANE2_FD_EXT         = 0x3278,
    EGL_DMA_BUF_PLANE2_OFFSET_EXT     = 0x3279,
    EGL_DMA_BUF_PLANE2_PITCH_EXT      = 0x327A,
    EGL_YUV_COLOR_SPACE_HINT_EXT      = 0x327B,
    EGL_SAMPLE_RANGE_HINT_EXT         = 0x327C,
    EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT = 0x327D,
    EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT = 0x327E,
    EGL_ITU_REC601_EXT                = 0x327F,
    EGL_ITU_REC709_EXT                = 0x3280,
    EGL_ITU_REC2020_EXT               = 0x3281,
    EGL_YUV_FULL_RANGE_EXT            = 0x3282,
    EGL_YUV_NARROW_RANGE_EXT          = 0x3283,
    EGL_YUV_CHROMA_SITING_0_EXT       = 0x3284,
    EGL_YUV_CHROMA_SITING_0_5_EXT     = 0x3285,
}

private __gshared bool _EGL_EXT_multiview_window;
bool EGL_EXT_multiview_window() @property { return _EGL_EXT_multiview_window; }
enum : uint {
    EGL_MULTIVIEW_VIEW_COUNT_EXT      = 0x3134,
}

private __gshared bool _EGL_EXT_platform_base;
bool EGL_EXT_platform_base() @property { return _EGL_EXT_platform_base; }
extern( System ) nothrow {
    alias EGLDisplay function( EGLenum, void*, const EGLint* ) da_eglGetPlatformDisplayEXT;
    alias EGLSurface function( EGLDisplay, EGLConfig, void*, const EGLint* ) da_eglCreatePlatformWindowSurfaceEXT;
    alias EGLSurface function( EGLDisplay, EGLConfig, void*, const EGLint* ) da_eglCreatePlatformPixmapSurfaceEXT;
}
__gshared {
    da_eglGetPlatformDisplayEXT eglGetPlatformDisplayEXT;
    da_eglCreatePlatformWindowSurfaceEXT eglCreatePlatformWindowSurfaceEXT;
    da_eglCreatePlatformPixmapSurfaceEXT eglCreatePlatformPixmapSurfaceEXT;
}
private void load_EGL_EXT_platform_base() {
    try {
        bindGLFunc( cast( void** )&eglGetPlatformDisplayEXT, "eglGetPlatformDisplayEXT" );
        bindGLFunc( cast( void** )&eglCreatePlatformWindowSurfaceEXT, "eglCreatePlatformWindowSurfaceEXT" );
        bindGLFunc( cast( void** )&eglCreatePlatformPixmapSurfaceEXT, "eglCreatePlatformPixmapSurfaceEXT" );

        _EGL_EXT_platform_base = true;
    } catch( Exception e ) {
        _EGL_EXT_platform_base = false;
    }
}

private __gshared bool _EGL_EXT_platform_device;
bool EGL_EXT_platform_device() @property { return _EGL_EXT_platform_device; }
enum : uint {
    EGL_PLATFORM_DEVICE_EXT           = 0x313F,
}

private __gshared bool _EGL_EXT_platform_wayland;
bool EGL_EXT_platform_wayland() @property { return _EGL_EXT_platform_wayland; }
enum : uint {
    EGL_PLATFORM_WAYLAND_EXT          = 0x31D8,
}

private __gshared bool _EGL_EXT_platform_x11;
bool EGL_EXT_platform_x11() @property { return _EGL_EXT_platform_x11; }
enum : uint {
    EGL_PLATFORM_X11_EXT              = 0x31D5,
    EGL_PLATFORM_X11_SCREEN_EXT       = 0x31D6,
}

private __gshared bool _EGL_EXT_protected_surface;
bool EGL_EXT_protected_surface() @property { return _EGL_EXT_protected_surface; }
enum : uint {
    EGL_PROTECTED_CONTENT_EXT         = 0x32C0,
}

private __gshared bool _EGL_EXT_swap_buffers_with_damage;
bool EGL_EXT_swap_buffers_with_damage() @property { return _EGL_EXT_swap_buffers_with_damage; }
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLSurface, EGLint*, EGLint ) da_eglSwapBuffersWithDamageEXT;
}
__gshared {
    da_eglSwapBuffersWithDamageEXT eglSwapBuffersWithDamageEXT;
}
private void load_EGL_EXT_swap_buffers_with_damage() {
    try {
        bindGLFunc( cast( void** )&eglSwapBuffersWithDamageEXT, "eglSwapBuffersWithDamageEXT" );

        _EGL_EXT_swap_buffers_with_damage = true;
    } catch( Exception e ) {
        _EGL_EXT_swap_buffers_with_damage = false;
    }
}

private __gshared bool _EGL_HI_clientpixmap;
bool EGL_HI_clientpixmap() @property { return _EGL_HI_clientpixmap; }
struct EGLClientPixmapHI {
    void * pData;
    EGLint iWidth;
    EGLint iHeight;
    EGLint iStride;
};
enum : uint {
    EGL_CLIENT_PIXMAP_POINTER_HI      = 0x8F74,
}
extern( System ) nothrow {
    alias EGLSurface function( EGLDisplay, EGLConfig, EGLClientPixmapHI* ) da_eglCreatePixmapSurfaceHI;
}
__gshared {
    da_eglCreatePixmapSurfaceHI eglCreatePixmapSurfaceHI;
}
private void load_EGL_HI_clientpixmap() {
    try {
        bindGLFunc( cast( void** )&eglCreatePixmapSurfaceHI, "eglCreatePixmapSurfaceHI" );

        _EGL_HI_clientpixmap = true;
    } catch( Exception e ) {
        _EGL_HI_clientpixmap = false;
    }
}

private __gshared bool _EGL_HI_colorformats;
bool EGL_HI_colorformats() @property { return _EGL_HI_colorformats; }
enum : uint {
    EGL_COLOR_FORMAT_HI               = 0x8F70,
    EGL_COLOR_RGB_HI                  = 0x8F71,
    EGL_COLOR_RGBA_HI                 = 0x8F72,
    EGL_COLOR_ARGB_HI                 = 0x8F73,
}

private __gshared bool _EGL_IMG_context_priority;
bool EGL_IMG_context_priority() @property { return _EGL_IMG_context_priority; }
enum : uint {
    EGL_CONTEXT_PRIORITY_LEVEL_IMG    = 0x3100,
    EGL_CONTEXT_PRIORITY_HIGH_IMG     = 0x3101,
    EGL_CONTEXT_PRIORITY_MEDIUM_IMG   = 0x3102,
    EGL_CONTEXT_PRIORITY_LOW_IMG      = 0x3103,
}

private __gshared bool _EGL_MESA_drm_image;
bool EGL_MESA_drm_image() @property { return _EGL_MESA_drm_image; }
enum : uint {
    EGL_DRM_BUFFER_FORMAT_MESA        = 0x31D0,
    EGL_DRM_BUFFER_USE_MESA           = 0x31D1,
    EGL_DRM_BUFFER_FORMAT_ARGB32_MESA = 0x31D2,
    EGL_DRM_BUFFER_MESA               = 0x31D3,
    EGL_DRM_BUFFER_STRIDE_MESA        = 0x31D4,
    EGL_DRM_BUFFER_USE_SCANOUT_MESA   = 0x00000001,
    EGL_DRM_BUFFER_USE_SHARE_MESA     = 0x00000002,
}
extern( System ) nothrow {
    alias EGLImageKHR function( EGLDisplay, const EGLint* ) da_eglCreateDRMImageMESA;
    alias EGLBoolean function( EGLDisplay, EGLImageKHR, EGLint*, EGLint*, EGLint* ) da_eglExportDRMImageMESA;
}
__gshared {
    da_eglCreateDRMImageMESA eglCreateDRMImageMESA;
    da_eglExportDRMImageMESA eglExportDRMImageMESA;
}
private void load_EGL_MESA_drm_image() {
    try {
        bindGLFunc( cast( void** )&eglCreateDRMImageMESA, "eglCreateDRMImageMESA" );
        bindGLFunc( cast( void** )&eglExportDRMImageMESA, "eglExportDRMImageMESA" );

        _EGL_MESA_drm_image = true;
    } catch( Exception e ) {
        _EGL_MESA_drm_image = false;
    }
}

private __gshared bool _EGL_MESA_platform_gbm;
bool EGL_MESA_platform_gbm() @property { return _EGL_MESA_platform_gbm; }
enum : uint {
    EGL_PLATFORM_GBM_MESA             = 0x31D7,
}

private __gshared bool _EGL_NOK_swap_region;
bool EGL_NOK_swap_region() @property { return _EGL_NOK_swap_region; }
EGLBoolean eglSwapBuffersRegionNOK( EGLDisplay, EGLSurface, EGLint, const EGLint* );

private __gshared bool _EGL_NOK_swap_region2;
bool EGL_NOK_swap_region2() @property { return _EGL_NOK_swap_region2; }
EGLBoolean eglSwapBuffersRegion2NOK( EGLDisplay, EGLSurface, EGLint, const EGLint* );

private __gshared bool _EGL_NOK_texture_from_pixmap;
bool EGL_NOK_texture_from_pixmap() @property { return _EGL_NOK_texture_from_pixmap; }
enum : uint {
    EGL_Y_INVERTED_NOK                = 0x307F,
}

private __gshared bool _EGL_NV_3dvision_surface;
bool EGL_NV_3dvision_surface() @property { return _EGL_NV_3dvision_surface; }
enum : uint {
    EGL_AUTO_STEREO_NV                = 0x3136,
}

private __gshared bool _EGL_NV_coverage_sample;
bool EGL_NV_coverage_sample() @property { return _EGL_NV_coverage_sample; }
enum : uint {
    EGL_COVERAGE_BUFFERS_NV           = 0x30E0,
    EGL_COVERAGE_SAMPLES_NV           = 0x30E1,
}

private __gshared bool _EGL_NV_coverage_sample_resolve;
bool EGL_NV_coverage_sample_resolve() @property { return _EGL_NV_coverage_sample_resolve; }
enum : uint {
    EGL_COVERAGE_SAMPLE_RESOLVE_NV    = 0x3131,
    EGL_COVERAGE_SAMPLE_RESOLVE_DEFAULT_NV = 0x3132,
    EGL_COVERAGE_SAMPLE_RESOLVE_NONE_NV = 0x3133,
}

private __gshared bool _EGL_NV_depth_nonlinear;
bool EGL_NV_depth_nonlinear() @property { return _EGL_NV_depth_nonlinear; }
enum : uint {
    EGL_DEPTH_ENCODING_NV             = 0x30E2,
    EGL_DEPTH_ENCODING_NONE_NV        = 0,
    EGL_DEPTH_ENCODING_NONLINEAR_NV   = 0x30E3,
}

private __gshared bool _EGL_NV_native_query;
bool EGL_NV_native_query() @property { return _EGL_NV_native_query; }
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLNativeDisplayType* ) da_eglQueryNativeDisplayNV;
    alias EGLBoolean function( EGLDisplay, EGLSurface, EGLNativeWindowType* ) da_eglQueryNativeWindowNV;
    alias EGLBoolean function( EGLDisplay, EGLSurface, EGLNativePixmapType* ) da_eglQueryNativePixmapNV;
}
__gshared {
    da_eglQueryNativeDisplayNV eglQueryNativeDisplayNV;
    da_eglQueryNativeWindowNV eglQueryNativeWindowNV;
    da_eglQueryNativePixmapNV eglQueryNativePixmapNV;
}
private void load_EGL_NV_native_query() {
    try {
        bindGLFunc( cast( void** )&eglQueryNativeDisplayNV, "eglQueryNativeDisplayNV" );
        bindGLFunc( cast( void** )&eglQueryNativeWindowNV, "eglQueryNativeWindowNV" );
        bindGLFunc( cast( void** )&eglQueryNativePixmapNV, "eglQueryNativePixmapNV" );

        _EGL_NV_native_query = true;
    } catch( Exception e ) {
        _EGL_NV_native_query = false;
    }
}

private __gshared bool _EGL_NV_post_convert_rounding;
bool EGL_NV_post_convert_rounding() @property { return _EGL_NV_post_convert_rounding; }

private __gshared bool _EGL_NV_post_sub_buffer;
bool EGL_NV_post_sub_buffer() @property { return _EGL_NV_post_sub_buffer; }
enum : uint {
    EGL_POST_SUB_BUFFER_SUPPORTED_NV  = 0x30BE,
}
extern( System ) nothrow {
    alias EGLBoolean function( EGLDisplay, EGLSurface, EGLint, EGLint, EGLint, EGLint ) da_eglPostSubBufferNV;
}
__gshared {
    da_eglPostSubBufferNV eglPostSubBufferNV;
}
private void load_EGL_NV_post_sub_buffer() {
    try {
        bindGLFunc( cast( void** )&eglPostSubBufferNV, "eglPostSubBufferNV" );

        _EGL_NV_post_sub_buffer = true;
    } catch( Exception e ) {
        _EGL_NV_post_sub_buffer = false;
    }
}

private __gshared bool _EGL_NV_stream_sync;
bool EGL_NV_stream_sync() @property { return _EGL_NV_stream_sync; }
enum : uint {
    EGL_SYNC_NEW_FRAME_NV             = 0x321F,
}
extern( System ) nothrow {
    alias EGLSyncKHR function( EGLDisplay, EGLStreamKHR, EGLenum, const EGLint* ) da_eglCreateStreamSyncNV;
}
__gshared {
    da_eglCreateStreamSyncNV eglCreateStreamSyncNV;
}
private void load_EGL_NV_stream_sync() {
    try {
        bindGLFunc( cast( void** )&eglCreateStreamSyncNV, "eglCreateStreamSyncNV" );

        _EGL_NV_stream_sync = true;
    } catch( Exception e ) {
        _EGL_NV_stream_sync = false;
    }
}

private __gshared bool _EGL_NV_sync;
bool EGL_NV_sync() @property { return _EGL_NV_sync; }
alias EGLSyncNV = void*;
alias EGLTimeNV = ulong;
enum EGLSyncNV EGL_NO_SYNC_NV = null;
enum EGLTimeNV EGL_FOREVER_NV = 0xFFFFFFFFFFFFFFFFUL;
enum : uint {
    EGL_SYNC_PRIOR_COMMANDS_COMPLETE_NV = 0x30E6,
    EGL_SYNC_STATUS_NV                = 0x30E7,
    EGL_SIGNALED_NV                   = 0x30E8,
    EGL_UNSIGNALED_NV                 = 0x30E9,
    EGL_SYNC_FLUSH_COMMANDS_BIT_NV    = 0x0001,
    EGL_ALREADY_SIGNALED_NV           = 0x30EA,
    EGL_TIMEOUT_EXPIRED_NV            = 0x30EB,
    EGL_CONDITION_SATISFIED_NV        = 0x30EC,
    EGL_SYNC_TYPE_NV                  = 0x30ED,
    EGL_SYNC_CONDITION_NV             = 0x30EE,
    EGL_SYNC_FENCE_NV                 = 0x30EF,
}
extern( System ) nothrow {
    alias EGLSyncNV function( EGLDisplay, EGLenum, const EGLint* ) da_eglCreateFenceSyncNV;
    alias EGLBoolean function( EGLSyncNV ) da_eglDestroySyncNV;
    alias EGLBoolean function( EGLSyncNV ) da_eglFenceNV;
    alias EGLint function( EGLSyncNV, EGLint, EGLTimeNV ) da_eglClientWaitSyncNV;
    alias EGLBoolean function( EGLSyncNV, EGLenum ) da_eglSignalSyncNV;
    alias EGLBoolean function( EGLSyncNV, EGLint, EGLint* ) da_eglGetSyncAttribNV;
}
__gshared {
    da_eglCreateFenceSyncNV eglCreateFenceSyncNV;
    da_eglDestroySyncNV eglDestroySyncNV;
    da_eglFenceNV eglFenceNV;
    da_eglClientWaitSyncNV eglClientWaitSyncNV;
    da_eglSignalSyncNV eglSignalSyncNV;
    da_eglGetSyncAttribNV eglGetSyncAttribNV;
}
private void load_EGL_NV_sync() {
    try {
        bindGLFunc( cast( void** )&eglCreateFenceSyncNV, "eglCreateFenceSyncNV" );
        bindGLFunc( cast( void** )&eglDestroySyncNV, "eglDestroySyncNV" );
        bindGLFunc( cast( void** )&eglFenceNV, "eglFenceNV" );
        bindGLFunc( cast( void** )&eglClientWaitSyncNV, "eglClientWaitSyncNV" );
        bindGLFunc( cast( void** )&eglSignalSyncNV, "eglSignalSyncNV" );
        bindGLFunc( cast( void** )&eglGetSyncAttribNV, "eglGetSyncAttribNV" );

        _EGL_NV_sync = true;
    } catch( Exception e ) {
        _EGL_NV_sync = false;
    }
}

private __gshared bool _EGL_NV_system_time;
bool EGL_NV_system_time() @property { return _EGL_NV_system_time; }
alias EGLuint64NV = ulong;
extern( System ) nothrow {
    alias EGLuint64NV function (  ) da_eglGetSystemTimeFrequencyNV;
    alias EGLuint64NV function (  ) da_eglGetSystemTimeNV;
}
__gshared {
    da_eglGetSystemTimeFrequencyNV eglGetSystemTimeFrequencyNV;
    da_eglGetSystemTimeNV eglGetSystemTimeNV;
}
private void load_EGL_NV_system_time() {
    try {
        bindGLFunc( cast( void** )&eglGetSystemTimeFrequencyNV, "eglGetSystemTimeFrequencyNV" );
        bindGLFunc( cast( void** )&eglGetSystemTimeNV, "eglGetSystemTimeNV" );

        _EGL_NV_system_time = true;
    } catch( Exception e ) {
        _EGL_NV_system_time = false;
    }
}

package void loadEXT( EGLDisplay disp ) {
    _EGL_KHR_cl_event = isEGLExtSupported( disp, "EGL_KHR_cl_event" );
    _EGL_KHR_cl_event2 = isEGLExtSupported( disp, "EGL_KHR_cl_event2" );
    if( _EGL_KHR_cl_event2 ) load_EGL_KHR_cl_event2();
    _EGL_KHR_client_get_all_proc_addresses = isEGLExtSupported( disp, "EGL_KHR_client_get_all_proc_addresses" );
    _EGL_KHR_config_attribs = isEGLExtSupported( disp, "EGL_KHR_config_attribs" );
    _EGL_KHR_create_context = isEGLExtSupported( disp, "EGL_KHR_create_context" );
    _EGL_KHR_fence_sync = isEGLExtSupported( disp, "EGL_KHR_fence_sync" );
    _EGL_KHR_get_all_proc_addresses = isEGLExtSupported( disp, "EGL_KHR_get_all_proc_addresses" );
    _EGL_KHR_gl_colorspace = isEGLExtSupported( disp, "EGL_KHR_gl_colorspace" );
    _EGL_KHR_gl_renderbuffer_image = isEGLExtSupported( disp, "EGL_KHR_gl_renderbuffer_image" );
    _EGL_KHR_gl_texture_2D_image = isEGLExtSupported( disp, "EGL_KHR_gl_texture_2D_image" );
    _EGL_KHR_gl_texture_3D_image = isEGLExtSupported( disp, "EGL_KHR_gl_texture_3D_image" );
    _EGL_KHR_gl_texture_cubemap_image = isEGLExtSupported( disp, "EGL_KHR_gl_texture_cubemap_image" );
    _EGL_KHR_image = isEGLExtSupported( disp, "EGL_KHR_image" );
    if( _EGL_KHR_image ) load_EGL_KHR_image();
    _EGL_KHR_image_base = isEGLExtSupported( disp, "EGL_KHR_image_base" );
    _EGL_KHR_image_pixmap = isEGLExtSupported( disp, "EGL_KHR_image_pixmap" );
    _EGL_KHR_lock_surface = isEGLExtSupported( disp, "EGL_KHR_lock_surface" );
    if( _EGL_KHR_lock_surface ) load_EGL_KHR_lock_surface();
    _EGL_KHR_lock_surface2 = isEGLExtSupported( disp, "EGL_KHR_lock_surface2" );
    _EGL_KHR_lock_surface3 = isEGLExtSupported( disp, "EGL_KHR_lock_surface3" );
    if( _EGL_KHR_lock_surface3 ) load_EGL_KHR_lock_surface3();
    _EGL_KHR_platform_android = isEGLExtSupported( disp, "EGL_KHR_platform_android" );
    _EGL_KHR_platform_gbm = isEGLExtSupported( disp, "EGL_KHR_platform_gbm" );
    _EGL_KHR_platform_wayland = isEGLExtSupported( disp, "EGL_KHR_platform_wayland" );
    _EGL_KHR_platform_x11 = isEGLExtSupported( disp, "EGL_KHR_platform_x11" );
    _EGL_KHR_reusable_sync = isEGLExtSupported( disp, "EGL_KHR_reusable_sync" );
    if( _EGL_KHR_reusable_sync ) load_EGL_KHR_reusable_sync();
    _EGL_KHR_stream = isEGLExtSupported( disp, "EGL_KHR_stream" );
    if( _EGL_KHR_stream ) load_EGL_KHR_stream();
    _EGL_KHR_stream_consumer_gltexture = isEGLExtSupported( disp, "EGL_KHR_stream_consumer_gltexture" );
    if( _EGL_KHR_stream_consumer_gltexture ) load_EGL_KHR_stream_consumer_gltexture();
    _EGL_KHR_stream_cross_process_fd = isEGLExtSupported( disp, "EGL_KHR_stream_cross_process_fd" );
    _EGL_KHR_stream_fifo = isEGLExtSupported( disp, "EGL_KHR_stream_fifo" );
    if( _EGL_KHR_stream_fifo ) load_EGL_KHR_stream_fifo();
    _EGL_KHR_stream_producer_aldatalocator = isEGLExtSupported( disp, "EGL_KHR_stream_producer_aldatalocator" );
    _EGL_KHR_stream_producer_eglsurface = isEGLExtSupported( disp, "EGL_KHR_stream_producer_eglsurface" );
    if( _EGL_KHR_stream_producer_eglsurface ) load_EGL_KHR_stream_producer_eglsurface();
    _EGL_KHR_surfaceless_context = isEGLExtSupported( disp, "EGL_KHR_surfaceless_context" );
    _EGL_KHR_vg_parent_image = isEGLExtSupported( disp, "EGL_KHR_vg_parent_image" );
    _EGL_KHR_wait_sync = isEGLExtSupported( disp, "EGL_KHR_wait_sync" );
    if( _EGL_KHR_wait_sync ) load_EGL_KHR_wait_sync();
    _EGL_ANDROID_blob_cache = isEGLExtSupported( disp, "EGL_ANDROID_blob_cache" );
    if( _EGL_ANDROID_blob_cache ) load_EGL_ANDROID_blob_cache();
    _EGL_ANDROID_framebuffer_target = isEGLExtSupported( disp, "EGL_ANDROID_framebuffer_target" );
    _EGL_ANDROID_image_native_buffer = isEGLExtSupported( disp, "EGL_ANDROID_image_native_buffer" );
    _EGL_ANDROID_native_fence_sync = isEGLExtSupported( disp, "EGL_ANDROID_native_fence_sync" );
    if( _EGL_ANDROID_native_fence_sync ) load_EGL_ANDROID_native_fence_sync();
    _EGL_ANDROID_recordable = isEGLExtSupported( disp, "EGL_ANDROID_recordable" );
    _EGL_ANGLE_d3d_share_handle_client_buffer = isEGLExtSupported( disp, "EGL_ANGLE_d3d_share_handle_client_buffer" );
    _EGL_ANGLE_query_surface_pointer = isEGLExtSupported( disp, "EGL_ANGLE_query_surface_pointer" );
    if( _EGL_ANGLE_query_surface_pointer ) load_EGL_ANGLE_query_surface_pointer();
    _EGL_ANGLE_surface_d3d_texture_2d_share_handle = isEGLExtSupported( disp, "EGL_ANGLE_surface_d3d_texture_2d_share_handle" );
    _EGL_ARM_pixmap_multisample_discard = isEGLExtSupported( disp, "EGL_ARM_pixmap_multisample_discard" );
    _EGL_EXT_buffer_age = isEGLExtSupported( disp, "EGL_EXT_buffer_age" );
    _EGL_EXT_client_extensions = isEGLExtSupported( disp, "EGL_EXT_client_extensions" );
    _EGL_EXT_create_context_robustness = isEGLExtSupported( disp, "EGL_EXT_create_context_robustness" );
    _EGL_EXT_device_base = isEGLExtSupported( disp, "EGL_EXT_device_base" );
    if( _EGL_EXT_device_base ) load_EGL_EXT_device_base();
    _EGL_EXT_image_dma_buf_import = isEGLExtSupported( disp, "EGL_EXT_image_dma_buf_import" );
    _EGL_EXT_multiview_window = isEGLExtSupported( disp, "EGL_EXT_multiview_window" );
    _EGL_EXT_platform_base = isEGLExtSupported( disp, "EGL_EXT_platform_base" );
    if( _EGL_EXT_platform_base ) load_EGL_EXT_platform_base();
    _EGL_EXT_platform_device = isEGLExtSupported( disp, "EGL_EXT_platform_device" );
    _EGL_EXT_platform_wayland = isEGLExtSupported( disp, "EGL_EXT_platform_wayland" );
    _EGL_EXT_platform_x11 = isEGLExtSupported( disp, "EGL_EXT_platform_x11" );
    _EGL_EXT_protected_surface = isEGLExtSupported( disp, "EGL_EXT_protected_surface" );
    _EGL_EXT_swap_buffers_with_damage = isEGLExtSupported( disp, "EGL_EXT_swap_buffers_with_damage" );
    if( _EGL_EXT_swap_buffers_with_damage ) load_EGL_EXT_swap_buffers_with_damage();
    _EGL_HI_clientpixmap = isEGLExtSupported( disp, "EGL_HI_clientpixmap" );
    if( _EGL_HI_clientpixmap ) load_EGL_HI_clientpixmap();
    _EGL_HI_colorformats = isEGLExtSupported( disp, "EGL_HI_colorformats" );
    _EGL_IMG_context_priority = isEGLExtSupported( disp, "EGL_IMG_context_priority" );
    _EGL_MESA_drm_image = isEGLExtSupported( disp, "EGL_MESA_drm_image" );
    if( _EGL_MESA_drm_image ) load_EGL_MESA_drm_image();
    _EGL_MESA_platform_gbm = isEGLExtSupported( disp, "EGL_MESA_platform_gbm" );
    _EGL_NOK_swap_region = isEGLExtSupported( disp, "EGL_NOK_swap_region" );
    _EGL_NOK_swap_region2 = isEGLExtSupported( disp, "EGL_NOK_swap_region2" );
    _EGL_NOK_texture_from_pixmap = isEGLExtSupported( disp, "EGL_NOK_texture_from_pixmap" );
    _EGL_NV_3dvision_surface = isEGLExtSupported( disp, "EGL_NV_3dvision_surface" );
    _EGL_NV_coverage_sample = isEGLExtSupported( disp, "EGL_NV_coverage_sample" );
    _EGL_NV_coverage_sample_resolve = isEGLExtSupported( disp, "EGL_NV_coverage_sample_resolve" );
    _EGL_NV_depth_nonlinear = isEGLExtSupported( disp, "EGL_NV_depth_nonlinear" );
    _EGL_NV_native_query = isEGLExtSupported( disp, "EGL_NV_native_query" );
    if( _EGL_NV_native_query ) load_EGL_NV_native_query();
    _EGL_NV_post_convert_rounding = isEGLExtSupported( disp, "EGL_NV_post_convert_rounding" );
    _EGL_NV_post_sub_buffer = isEGLExtSupported( disp, "EGL_NV_post_sub_buffer" );
    if( _EGL_NV_post_sub_buffer ) load_EGL_NV_post_sub_buffer();
    _EGL_NV_stream_sync = isEGLExtSupported( disp, "EGL_NV_stream_sync" );
    if( _EGL_NV_stream_sync ) load_EGL_NV_stream_sync();
    _EGL_NV_sync = isEGLExtSupported( disp, "EGL_NV_sync" );
    if( _EGL_NV_sync ) load_EGL_NV_sync();
    _EGL_NV_system_time = isEGLExtSupported( disp, "EGL_NV_system_time" );
    if( _EGL_NV_system_time ) load_EGL_NV_system_time();
}
